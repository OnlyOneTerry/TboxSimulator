// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "connection.pb.h"
#include "status.pb.h"
#include "control.pb.h"
#include "diagnose.pb.h"
#include "alert.pb.h"
#include "fault.pb.h"
#include "analysis.pb.h"
#include "gb32960.pb.h"
#include "lock.pb.h"
#include "event.pb.h"
#include "ota.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace MessageNS {
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace MessageNS
PROTOBUF_NAMESPACE_OPEN
template<> ::MessageNS::Message* Arena::CreateMaybeMessage<::MessageNS::Message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MessageNS {

enum Aid : int {
  CONNECTION = 0,
  STATUS = 1,
  CONTROL = 2,
  DIAGNOSE = 3,
  ALERT = 4,
  FAULT = 5,
  ANALYSIS = 6,
  GB32960 = 7,
  LOCK = 8,
  EVENT = 9,
  OTA = 10,
  OTA_STEP = 11,
  Aid_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Aid_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Aid_IsValid(int value);
constexpr Aid Aid_MIN = CONNECTION;
constexpr Aid Aid_MAX = OTA_STEP;
constexpr int Aid_ARRAYSIZE = Aid_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aid_descriptor();
template<typename T>
inline const std::string& Aid_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Aid>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Aid_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Aid_descriptor(), enum_t_value);
}
inline bool Aid_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Aid* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Aid>(
    Aid_descriptor(), name, value);
}
// ===================================================================

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MessageNS.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MessageNS.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionFieldNumber = 2,
    kStatusFieldNumber = 3,
    kControlFieldNumber = 4,
    kDiagnoseFieldNumber = 5,
    kAlertFieldNumber = 6,
    kFaultFieldNumber = 7,
    kAnalysisFieldNumber = 8,
    kGb32960FieldNumber = 9,
    kLockFieldNumber = 10,
    kEventFieldNumber = 11,
    kOtaFieldNumber = 12,
    kOtaStepFieldNumber = 13,
    kAidFieldNumber = 1,
  };
  // .ConnectionNS.Connection connection = 2;
  bool has_connection() const;
  private:
  bool _internal_has_connection() const;
  public:
  void clear_connection();
  const ::ConnectionNS::Connection& connection() const;
  PROTOBUF_NODISCARD ::ConnectionNS::Connection* release_connection();
  ::ConnectionNS::Connection* mutable_connection();
  void set_allocated_connection(::ConnectionNS::Connection* connection);
  private:
  const ::ConnectionNS::Connection& _internal_connection() const;
  ::ConnectionNS::Connection* _internal_mutable_connection();
  public:
  void unsafe_arena_set_allocated_connection(
      ::ConnectionNS::Connection* connection);
  ::ConnectionNS::Connection* unsafe_arena_release_connection();

  // .StatusNS.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::StatusNS::Status& status() const;
  PROTOBUF_NODISCARD ::StatusNS::Status* release_status();
  ::StatusNS::Status* mutable_status();
  void set_allocated_status(::StatusNS::Status* status);
  private:
  const ::StatusNS::Status& _internal_status() const;
  ::StatusNS::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::StatusNS::Status* status);
  ::StatusNS::Status* unsafe_arena_release_status();

  // .ControlNS.Control control = 4;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::ControlNS::Control& control() const;
  PROTOBUF_NODISCARD ::ControlNS::Control* release_control();
  ::ControlNS::Control* mutable_control();
  void set_allocated_control(::ControlNS::Control* control);
  private:
  const ::ControlNS::Control& _internal_control() const;
  ::ControlNS::Control* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::ControlNS::Control* control);
  ::ControlNS::Control* unsafe_arena_release_control();

  // .DiagnoseNS.Diagnose diagnose = 5;
  bool has_diagnose() const;
  private:
  bool _internal_has_diagnose() const;
  public:
  void clear_diagnose();
  const ::DiagnoseNS::Diagnose& diagnose() const;
  PROTOBUF_NODISCARD ::DiagnoseNS::Diagnose* release_diagnose();
  ::DiagnoseNS::Diagnose* mutable_diagnose();
  void set_allocated_diagnose(::DiagnoseNS::Diagnose* diagnose);
  private:
  const ::DiagnoseNS::Diagnose& _internal_diagnose() const;
  ::DiagnoseNS::Diagnose* _internal_mutable_diagnose();
  public:
  void unsafe_arena_set_allocated_diagnose(
      ::DiagnoseNS::Diagnose* diagnose);
  ::DiagnoseNS::Diagnose* unsafe_arena_release_diagnose();

  // .AlertNS.Alert alert = 6;
  bool has_alert() const;
  private:
  bool _internal_has_alert() const;
  public:
  void clear_alert();
  const ::AlertNS::Alert& alert() const;
  PROTOBUF_NODISCARD ::AlertNS::Alert* release_alert();
  ::AlertNS::Alert* mutable_alert();
  void set_allocated_alert(::AlertNS::Alert* alert);
  private:
  const ::AlertNS::Alert& _internal_alert() const;
  ::AlertNS::Alert* _internal_mutable_alert();
  public:
  void unsafe_arena_set_allocated_alert(
      ::AlertNS::Alert* alert);
  ::AlertNS::Alert* unsafe_arena_release_alert();

  // .FaultNS.Fault fault = 7;
  bool has_fault() const;
  private:
  bool _internal_has_fault() const;
  public:
  void clear_fault();
  const ::FaultNS::Fault& fault() const;
  PROTOBUF_NODISCARD ::FaultNS::Fault* release_fault();
  ::FaultNS::Fault* mutable_fault();
  void set_allocated_fault(::FaultNS::Fault* fault);
  private:
  const ::FaultNS::Fault& _internal_fault() const;
  ::FaultNS::Fault* _internal_mutable_fault();
  public:
  void unsafe_arena_set_allocated_fault(
      ::FaultNS::Fault* fault);
  ::FaultNS::Fault* unsafe_arena_release_fault();

  // .AnalysisNS.Analysis analysis = 8;
  bool has_analysis() const;
  private:
  bool _internal_has_analysis() const;
  public:
  void clear_analysis();
  const ::AnalysisNS::Analysis& analysis() const;
  PROTOBUF_NODISCARD ::AnalysisNS::Analysis* release_analysis();
  ::AnalysisNS::Analysis* mutable_analysis();
  void set_allocated_analysis(::AnalysisNS::Analysis* analysis);
  private:
  const ::AnalysisNS::Analysis& _internal_analysis() const;
  ::AnalysisNS::Analysis* _internal_mutable_analysis();
  public:
  void unsafe_arena_set_allocated_analysis(
      ::AnalysisNS::Analysis* analysis);
  ::AnalysisNS::Analysis* unsafe_arena_release_analysis();

  // .Gb32960NS.Gb32960 gb32960 = 9;
  bool has_gb32960() const;
  private:
  bool _internal_has_gb32960() const;
  public:
  void clear_gb32960();
  const ::Gb32960NS::Gb32960& gb32960() const;
  PROTOBUF_NODISCARD ::Gb32960NS::Gb32960* release_gb32960();
  ::Gb32960NS::Gb32960* mutable_gb32960();
  void set_allocated_gb32960(::Gb32960NS::Gb32960* gb32960);
  private:
  const ::Gb32960NS::Gb32960& _internal_gb32960() const;
  ::Gb32960NS::Gb32960* _internal_mutable_gb32960();
  public:
  void unsafe_arena_set_allocated_gb32960(
      ::Gb32960NS::Gb32960* gb32960);
  ::Gb32960NS::Gb32960* unsafe_arena_release_gb32960();

  // .LockNS.Lock lock = 10;
  bool has_lock() const;
  private:
  bool _internal_has_lock() const;
  public:
  void clear_lock();
  const ::LockNS::Lock& lock() const;
  PROTOBUF_NODISCARD ::LockNS::Lock* release_lock();
  ::LockNS::Lock* mutable_lock();
  void set_allocated_lock(::LockNS::Lock* lock);
  private:
  const ::LockNS::Lock& _internal_lock() const;
  ::LockNS::Lock* _internal_mutable_lock();
  public:
  void unsafe_arena_set_allocated_lock(
      ::LockNS::Lock* lock);
  ::LockNS::Lock* unsafe_arena_release_lock();

  // .EventNS.Event event = 11;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::EventNS::Event& event() const;
  PROTOBUF_NODISCARD ::EventNS::Event* release_event();
  ::EventNS::Event* mutable_event();
  void set_allocated_event(::EventNS::Event* event);
  private:
  const ::EventNS::Event& _internal_event() const;
  ::EventNS::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::EventNS::Event* event);
  ::EventNS::Event* unsafe_arena_release_event();

  // .OTANS.OTA ota = 12;
  bool has_ota() const;
  private:
  bool _internal_has_ota() const;
  public:
  void clear_ota();
  const ::OTANS::OTA& ota() const;
  PROTOBUF_NODISCARD ::OTANS::OTA* release_ota();
  ::OTANS::OTA* mutable_ota();
  void set_allocated_ota(::OTANS::OTA* ota);
  private:
  const ::OTANS::OTA& _internal_ota() const;
  ::OTANS::OTA* _internal_mutable_ota();
  public:
  void unsafe_arena_set_allocated_ota(
      ::OTANS::OTA* ota);
  ::OTANS::OTA* unsafe_arena_release_ota();

  // .OTANS.OTAStep otaStep = 13;
  bool has_otastep() const;
  private:
  bool _internal_has_otastep() const;
  public:
  void clear_otastep();
  const ::OTANS::OTAStep& otastep() const;
  PROTOBUF_NODISCARD ::OTANS::OTAStep* release_otastep();
  ::OTANS::OTAStep* mutable_otastep();
  void set_allocated_otastep(::OTANS::OTAStep* otastep);
  private:
  const ::OTANS::OTAStep& _internal_otastep() const;
  ::OTANS::OTAStep* _internal_mutable_otastep();
  public:
  void unsafe_arena_set_allocated_otastep(
      ::OTANS::OTAStep* otastep);
  ::OTANS::OTAStep* unsafe_arena_release_otastep();

  // .MessageNS.Aid aid = 1;
  void clear_aid();
  ::MessageNS::Aid aid() const;
  void set_aid(::MessageNS::Aid value);
  private:
  ::MessageNS::Aid _internal_aid() const;
  void _internal_set_aid(::MessageNS::Aid value);
  public:

  // @@protoc_insertion_point(class_scope:MessageNS.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ConnectionNS::Connection* connection_;
  ::StatusNS::Status* status_;
  ::ControlNS::Control* control_;
  ::DiagnoseNS::Diagnose* diagnose_;
  ::AlertNS::Alert* alert_;
  ::FaultNS::Fault* fault_;
  ::AnalysisNS::Analysis* analysis_;
  ::Gb32960NS::Gb32960* gb32960_;
  ::LockNS::Lock* lock_;
  ::EventNS::Event* event_;
  ::OTANS::OTA* ota_;
  ::OTANS::OTAStep* otastep_;
  int aid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// .MessageNS.Aid aid = 1;
inline void Message::clear_aid() {
  aid_ = 0;
}
inline ::MessageNS::Aid Message::_internal_aid() const {
  return static_cast< ::MessageNS::Aid >(aid_);
}
inline ::MessageNS::Aid Message::aid() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.aid)
  return _internal_aid();
}
inline void Message::_internal_set_aid(::MessageNS::Aid value) {
  
  aid_ = value;
}
inline void Message::set_aid(::MessageNS::Aid value) {
  _internal_set_aid(value);
  // @@protoc_insertion_point(field_set:MessageNS.Message.aid)
}

// .ConnectionNS.Connection connection = 2;
inline bool Message::_internal_has_connection() const {
  return this != internal_default_instance() && connection_ != nullptr;
}
inline bool Message::has_connection() const {
  return _internal_has_connection();
}
inline const ::ConnectionNS::Connection& Message::_internal_connection() const {
  const ::ConnectionNS::Connection* p = connection_;
  return p != nullptr ? *p : reinterpret_cast<const ::ConnectionNS::Connection&>(
      ::ConnectionNS::_Connection_default_instance_);
}
inline const ::ConnectionNS::Connection& Message::connection() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.connection)
  return _internal_connection();
}
inline void Message::unsafe_arena_set_allocated_connection(
    ::ConnectionNS::Connection* connection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_);
  }
  connection_ = connection;
  if (connection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.connection)
}
inline ::ConnectionNS::Connection* Message::release_connection() {
  
  ::ConnectionNS::Connection* temp = connection_;
  connection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ConnectionNS::Connection* Message::unsafe_arena_release_connection() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.connection)
  
  ::ConnectionNS::Connection* temp = connection_;
  connection_ = nullptr;
  return temp;
}
inline ::ConnectionNS::Connection* Message::_internal_mutable_connection() {
  
  if (connection_ == nullptr) {
    auto* p = CreateMaybeMessage<::ConnectionNS::Connection>(GetArenaForAllocation());
    connection_ = p;
  }
  return connection_;
}
inline ::ConnectionNS::Connection* Message::mutable_connection() {
  ::ConnectionNS::Connection* _msg = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.connection)
  return _msg;
}
inline void Message::set_allocated_connection(::ConnectionNS::Connection* connection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_);
  }
  if (connection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection));
    if (message_arena != submessage_arena) {
      connection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.connection)
}

// .StatusNS.Status status = 3;
inline bool Message::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Message::has_status() const {
  return _internal_has_status();
}
inline const ::StatusNS::Status& Message::_internal_status() const {
  const ::StatusNS::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::Status&>(
      ::StatusNS::_Status_default_instance_);
}
inline const ::StatusNS::Status& Message::status() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.status)
  return _internal_status();
}
inline void Message::unsafe_arena_set_allocated_status(
    ::StatusNS::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.status)
}
inline ::StatusNS::Status* Message::release_status() {
  
  ::StatusNS::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::Status* Message::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.status)
  
  ::StatusNS::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::StatusNS::Status* Message::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::StatusNS::Status* Message::mutable_status() {
  ::StatusNS::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.status)
  return _msg;
}
inline void Message::set_allocated_status(::StatusNS::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.status)
}

// .ControlNS.Control control = 4;
inline bool Message::_internal_has_control() const {
  return this != internal_default_instance() && control_ != nullptr;
}
inline bool Message::has_control() const {
  return _internal_has_control();
}
inline const ::ControlNS::Control& Message::_internal_control() const {
  const ::ControlNS::Control* p = control_;
  return p != nullptr ? *p : reinterpret_cast<const ::ControlNS::Control&>(
      ::ControlNS::_Control_default_instance_);
}
inline const ::ControlNS::Control& Message::control() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.control)
  return _internal_control();
}
inline void Message::unsafe_arena_set_allocated_control(
    ::ControlNS::Control* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_);
  }
  control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.control)
}
inline ::ControlNS::Control* Message::release_control() {
  
  ::ControlNS::Control* temp = control_;
  control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ControlNS::Control* Message::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.control)
  
  ::ControlNS::Control* temp = control_;
  control_ = nullptr;
  return temp;
}
inline ::ControlNS::Control* Message::_internal_mutable_control() {
  
  if (control_ == nullptr) {
    auto* p = CreateMaybeMessage<::ControlNS::Control>(GetArenaForAllocation());
    control_ = p;
  }
  return control_;
}
inline ::ControlNS::Control* Message::mutable_control() {
  ::ControlNS::Control* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.control)
  return _msg;
}
inline void Message::set_allocated_control(::ControlNS::Control* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_);
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control));
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    
  } else {
    
  }
  control_ = control;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.control)
}

// .DiagnoseNS.Diagnose diagnose = 5;
inline bool Message::_internal_has_diagnose() const {
  return this != internal_default_instance() && diagnose_ != nullptr;
}
inline bool Message::has_diagnose() const {
  return _internal_has_diagnose();
}
inline const ::DiagnoseNS::Diagnose& Message::_internal_diagnose() const {
  const ::DiagnoseNS::Diagnose* p = diagnose_;
  return p != nullptr ? *p : reinterpret_cast<const ::DiagnoseNS::Diagnose&>(
      ::DiagnoseNS::_Diagnose_default_instance_);
}
inline const ::DiagnoseNS::Diagnose& Message::diagnose() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.diagnose)
  return _internal_diagnose();
}
inline void Message::unsafe_arena_set_allocated_diagnose(
    ::DiagnoseNS::Diagnose* diagnose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diagnose_);
  }
  diagnose_ = diagnose;
  if (diagnose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.diagnose)
}
inline ::DiagnoseNS::Diagnose* Message::release_diagnose() {
  
  ::DiagnoseNS::Diagnose* temp = diagnose_;
  diagnose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DiagnoseNS::Diagnose* Message::unsafe_arena_release_diagnose() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.diagnose)
  
  ::DiagnoseNS::Diagnose* temp = diagnose_;
  diagnose_ = nullptr;
  return temp;
}
inline ::DiagnoseNS::Diagnose* Message::_internal_mutable_diagnose() {
  
  if (diagnose_ == nullptr) {
    auto* p = CreateMaybeMessage<::DiagnoseNS::Diagnose>(GetArenaForAllocation());
    diagnose_ = p;
  }
  return diagnose_;
}
inline ::DiagnoseNS::Diagnose* Message::mutable_diagnose() {
  ::DiagnoseNS::Diagnose* _msg = _internal_mutable_diagnose();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.diagnose)
  return _msg;
}
inline void Message::set_allocated_diagnose(::DiagnoseNS::Diagnose* diagnose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(diagnose_);
  }
  if (diagnose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diagnose));
    if (message_arena != submessage_arena) {
      diagnose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diagnose, submessage_arena);
    }
    
  } else {
    
  }
  diagnose_ = diagnose;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.diagnose)
}

// .AlertNS.Alert alert = 6;
inline bool Message::_internal_has_alert() const {
  return this != internal_default_instance() && alert_ != nullptr;
}
inline bool Message::has_alert() const {
  return _internal_has_alert();
}
inline const ::AlertNS::Alert& Message::_internal_alert() const {
  const ::AlertNS::Alert* p = alert_;
  return p != nullptr ? *p : reinterpret_cast<const ::AlertNS::Alert&>(
      ::AlertNS::_Alert_default_instance_);
}
inline const ::AlertNS::Alert& Message::alert() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.alert)
  return _internal_alert();
}
inline void Message::unsafe_arena_set_allocated_alert(
    ::AlertNS::Alert* alert) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_);
  }
  alert_ = alert;
  if (alert) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.alert)
}
inline ::AlertNS::Alert* Message::release_alert() {
  
  ::AlertNS::Alert* temp = alert_;
  alert_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AlertNS::Alert* Message::unsafe_arena_release_alert() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.alert)
  
  ::AlertNS::Alert* temp = alert_;
  alert_ = nullptr;
  return temp;
}
inline ::AlertNS::Alert* Message::_internal_mutable_alert() {
  
  if (alert_ == nullptr) {
    auto* p = CreateMaybeMessage<::AlertNS::Alert>(GetArenaForAllocation());
    alert_ = p;
  }
  return alert_;
}
inline ::AlertNS::Alert* Message::mutable_alert() {
  ::AlertNS::Alert* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.alert)
  return _msg;
}
inline void Message::set_allocated_alert(::AlertNS::Alert* alert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_);
  }
  if (alert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert));
    if (message_arena != submessage_arena) {
      alert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert, submessage_arena);
    }
    
  } else {
    
  }
  alert_ = alert;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.alert)
}

// .FaultNS.Fault fault = 7;
inline bool Message::_internal_has_fault() const {
  return this != internal_default_instance() && fault_ != nullptr;
}
inline bool Message::has_fault() const {
  return _internal_has_fault();
}
inline const ::FaultNS::Fault& Message::_internal_fault() const {
  const ::FaultNS::Fault* p = fault_;
  return p != nullptr ? *p : reinterpret_cast<const ::FaultNS::Fault&>(
      ::FaultNS::_Fault_default_instance_);
}
inline const ::FaultNS::Fault& Message::fault() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.fault)
  return _internal_fault();
}
inline void Message::unsafe_arena_set_allocated_fault(
    ::FaultNS::Fault* fault) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fault_);
  }
  fault_ = fault;
  if (fault) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.fault)
}
inline ::FaultNS::Fault* Message::release_fault() {
  
  ::FaultNS::Fault* temp = fault_;
  fault_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FaultNS::Fault* Message::unsafe_arena_release_fault() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.fault)
  
  ::FaultNS::Fault* temp = fault_;
  fault_ = nullptr;
  return temp;
}
inline ::FaultNS::Fault* Message::_internal_mutable_fault() {
  
  if (fault_ == nullptr) {
    auto* p = CreateMaybeMessage<::FaultNS::Fault>(GetArenaForAllocation());
    fault_ = p;
  }
  return fault_;
}
inline ::FaultNS::Fault* Message::mutable_fault() {
  ::FaultNS::Fault* _msg = _internal_mutable_fault();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.fault)
  return _msg;
}
inline void Message::set_allocated_fault(::FaultNS::Fault* fault) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fault_);
  }
  if (fault) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fault));
    if (message_arena != submessage_arena) {
      fault = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fault, submessage_arena);
    }
    
  } else {
    
  }
  fault_ = fault;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.fault)
}

// .AnalysisNS.Analysis analysis = 8;
inline bool Message::_internal_has_analysis() const {
  return this != internal_default_instance() && analysis_ != nullptr;
}
inline bool Message::has_analysis() const {
  return _internal_has_analysis();
}
inline const ::AnalysisNS::Analysis& Message::_internal_analysis() const {
  const ::AnalysisNS::Analysis* p = analysis_;
  return p != nullptr ? *p : reinterpret_cast<const ::AnalysisNS::Analysis&>(
      ::AnalysisNS::_Analysis_default_instance_);
}
inline const ::AnalysisNS::Analysis& Message::analysis() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.analysis)
  return _internal_analysis();
}
inline void Message::unsafe_arena_set_allocated_analysis(
    ::AnalysisNS::Analysis* analysis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(analysis_);
  }
  analysis_ = analysis;
  if (analysis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.analysis)
}
inline ::AnalysisNS::Analysis* Message::release_analysis() {
  
  ::AnalysisNS::Analysis* temp = analysis_;
  analysis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AnalysisNS::Analysis* Message::unsafe_arena_release_analysis() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.analysis)
  
  ::AnalysisNS::Analysis* temp = analysis_;
  analysis_ = nullptr;
  return temp;
}
inline ::AnalysisNS::Analysis* Message::_internal_mutable_analysis() {
  
  if (analysis_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnalysisNS::Analysis>(GetArenaForAllocation());
    analysis_ = p;
  }
  return analysis_;
}
inline ::AnalysisNS::Analysis* Message::mutable_analysis() {
  ::AnalysisNS::Analysis* _msg = _internal_mutable_analysis();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.analysis)
  return _msg;
}
inline void Message::set_allocated_analysis(::AnalysisNS::Analysis* analysis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(analysis_);
  }
  if (analysis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(analysis));
    if (message_arena != submessage_arena) {
      analysis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, analysis, submessage_arena);
    }
    
  } else {
    
  }
  analysis_ = analysis;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.analysis)
}

// .Gb32960NS.Gb32960 gb32960 = 9;
inline bool Message::_internal_has_gb32960() const {
  return this != internal_default_instance() && gb32960_ != nullptr;
}
inline bool Message::has_gb32960() const {
  return _internal_has_gb32960();
}
inline const ::Gb32960NS::Gb32960& Message::_internal_gb32960() const {
  const ::Gb32960NS::Gb32960* p = gb32960_;
  return p != nullptr ? *p : reinterpret_cast<const ::Gb32960NS::Gb32960&>(
      ::Gb32960NS::_Gb32960_default_instance_);
}
inline const ::Gb32960NS::Gb32960& Message::gb32960() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.gb32960)
  return _internal_gb32960();
}
inline void Message::unsafe_arena_set_allocated_gb32960(
    ::Gb32960NS::Gb32960* gb32960) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gb32960_);
  }
  gb32960_ = gb32960;
  if (gb32960) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.gb32960)
}
inline ::Gb32960NS::Gb32960* Message::release_gb32960() {
  
  ::Gb32960NS::Gb32960* temp = gb32960_;
  gb32960_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Gb32960NS::Gb32960* Message::unsafe_arena_release_gb32960() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.gb32960)
  
  ::Gb32960NS::Gb32960* temp = gb32960_;
  gb32960_ = nullptr;
  return temp;
}
inline ::Gb32960NS::Gb32960* Message::_internal_mutable_gb32960() {
  
  if (gb32960_ == nullptr) {
    auto* p = CreateMaybeMessage<::Gb32960NS::Gb32960>(GetArenaForAllocation());
    gb32960_ = p;
  }
  return gb32960_;
}
inline ::Gb32960NS::Gb32960* Message::mutable_gb32960() {
  ::Gb32960NS::Gb32960* _msg = _internal_mutable_gb32960();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.gb32960)
  return _msg;
}
inline void Message::set_allocated_gb32960(::Gb32960NS::Gb32960* gb32960) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gb32960_);
  }
  if (gb32960) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gb32960));
    if (message_arena != submessage_arena) {
      gb32960 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gb32960, submessage_arena);
    }
    
  } else {
    
  }
  gb32960_ = gb32960;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.gb32960)
}

// .LockNS.Lock lock = 10;
inline bool Message::_internal_has_lock() const {
  return this != internal_default_instance() && lock_ != nullptr;
}
inline bool Message::has_lock() const {
  return _internal_has_lock();
}
inline const ::LockNS::Lock& Message::_internal_lock() const {
  const ::LockNS::Lock* p = lock_;
  return p != nullptr ? *p : reinterpret_cast<const ::LockNS::Lock&>(
      ::LockNS::_Lock_default_instance_);
}
inline const ::LockNS::Lock& Message::lock() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.lock)
  return _internal_lock();
}
inline void Message::unsafe_arena_set_allocated_lock(
    ::LockNS::Lock* lock) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock_);
  }
  lock_ = lock;
  if (lock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.lock)
}
inline ::LockNS::Lock* Message::release_lock() {
  
  ::LockNS::Lock* temp = lock_;
  lock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LockNS::Lock* Message::unsafe_arena_release_lock() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.lock)
  
  ::LockNS::Lock* temp = lock_;
  lock_ = nullptr;
  return temp;
}
inline ::LockNS::Lock* Message::_internal_mutable_lock() {
  
  if (lock_ == nullptr) {
    auto* p = CreateMaybeMessage<::LockNS::Lock>(GetArenaForAllocation());
    lock_ = p;
  }
  return lock_;
}
inline ::LockNS::Lock* Message::mutable_lock() {
  ::LockNS::Lock* _msg = _internal_mutable_lock();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.lock)
  return _msg;
}
inline void Message::set_allocated_lock(::LockNS::Lock* lock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock_);
  }
  if (lock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock));
    if (message_arena != submessage_arena) {
      lock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lock, submessage_arena);
    }
    
  } else {
    
  }
  lock_ = lock;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.lock)
}

// .EventNS.Event event = 11;
inline bool Message::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool Message::has_event() const {
  return _internal_has_event();
}
inline const ::EventNS::Event& Message::_internal_event() const {
  const ::EventNS::Event* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::Event&>(
      ::EventNS::_Event_default_instance_);
}
inline const ::EventNS::Event& Message::event() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.event)
  return _internal_event();
}
inline void Message::unsafe_arena_set_allocated_event(
    ::EventNS::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.event)
}
inline ::EventNS::Event* Message::release_event() {
  
  ::EventNS::Event* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::Event* Message::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.event)
  
  ::EventNS::Event* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::EventNS::Event* Message::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::Event>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::EventNS::Event* Message::mutable_event() {
  ::EventNS::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.event)
  return _msg;
}
inline void Message::set_allocated_event(::EventNS::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.event)
}

// .OTANS.OTA ota = 12;
inline bool Message::_internal_has_ota() const {
  return this != internal_default_instance() && ota_ != nullptr;
}
inline bool Message::has_ota() const {
  return _internal_has_ota();
}
inline const ::OTANS::OTA& Message::_internal_ota() const {
  const ::OTANS::OTA* p = ota_;
  return p != nullptr ? *p : reinterpret_cast<const ::OTANS::OTA&>(
      ::OTANS::_OTA_default_instance_);
}
inline const ::OTANS::OTA& Message::ota() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.ota)
  return _internal_ota();
}
inline void Message::unsafe_arena_set_allocated_ota(
    ::OTANS::OTA* ota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ota_);
  }
  ota_ = ota;
  if (ota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.ota)
}
inline ::OTANS::OTA* Message::release_ota() {
  
  ::OTANS::OTA* temp = ota_;
  ota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OTANS::OTA* Message::unsafe_arena_release_ota() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.ota)
  
  ::OTANS::OTA* temp = ota_;
  ota_ = nullptr;
  return temp;
}
inline ::OTANS::OTA* Message::_internal_mutable_ota() {
  
  if (ota_ == nullptr) {
    auto* p = CreateMaybeMessage<::OTANS::OTA>(GetArenaForAllocation());
    ota_ = p;
  }
  return ota_;
}
inline ::OTANS::OTA* Message::mutable_ota() {
  ::OTANS::OTA* _msg = _internal_mutable_ota();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.ota)
  return _msg;
}
inline void Message::set_allocated_ota(::OTANS::OTA* ota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ota_);
  }
  if (ota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ota));
    if (message_arena != submessage_arena) {
      ota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ota, submessage_arena);
    }
    
  } else {
    
  }
  ota_ = ota;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.ota)
}

// .OTANS.OTAStep otaStep = 13;
inline bool Message::_internal_has_otastep() const {
  return this != internal_default_instance() && otastep_ != nullptr;
}
inline bool Message::has_otastep() const {
  return _internal_has_otastep();
}
inline const ::OTANS::OTAStep& Message::_internal_otastep() const {
  const ::OTANS::OTAStep* p = otastep_;
  return p != nullptr ? *p : reinterpret_cast<const ::OTANS::OTAStep&>(
      ::OTANS::_OTAStep_default_instance_);
}
inline const ::OTANS::OTAStep& Message::otastep() const {
  // @@protoc_insertion_point(field_get:MessageNS.Message.otaStep)
  return _internal_otastep();
}
inline void Message::unsafe_arena_set_allocated_otastep(
    ::OTANS::OTAStep* otastep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(otastep_);
  }
  otastep_ = otastep;
  if (otastep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageNS.Message.otaStep)
}
inline ::OTANS::OTAStep* Message::release_otastep() {
  
  ::OTANS::OTAStep* temp = otastep_;
  otastep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OTANS::OTAStep* Message::unsafe_arena_release_otastep() {
  // @@protoc_insertion_point(field_release:MessageNS.Message.otaStep)
  
  ::OTANS::OTAStep* temp = otastep_;
  otastep_ = nullptr;
  return temp;
}
inline ::OTANS::OTAStep* Message::_internal_mutable_otastep() {
  
  if (otastep_ == nullptr) {
    auto* p = CreateMaybeMessage<::OTANS::OTAStep>(GetArenaForAllocation());
    otastep_ = p;
  }
  return otastep_;
}
inline ::OTANS::OTAStep* Message::mutable_otastep() {
  ::OTANS::OTAStep* _msg = _internal_mutable_otastep();
  // @@protoc_insertion_point(field_mutable:MessageNS.Message.otaStep)
  return _msg;
}
inline void Message::set_allocated_otastep(::OTANS::OTAStep* otastep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(otastep_);
  }
  if (otastep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(otastep));
    if (message_arena != submessage_arena) {
      otastep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, otastep, submessage_arena);
    }
    
  } else {
    
  }
  otastep_ = otastep;
  // @@protoc_insertion_point(field_set_allocated:MessageNS.Message.otaStep)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace MessageNS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MessageNS::Aid> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageNS::Aid>() {
  return ::MessageNS::Aid_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
