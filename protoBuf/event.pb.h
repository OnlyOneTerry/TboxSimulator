// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_event_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_event_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_event_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_event_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_event_2eproto;
namespace EventNS {
class BatteryInfo;
struct BatteryInfoDefaultTypeInternal;
extern BatteryInfoDefaultTypeInternal _BatteryInfo_default_instance_;
class BluetoothInfo;
struct BluetoothInfoDefaultTypeInternal;
extern BluetoothInfoDefaultTypeInternal _BluetoothInfo_default_instance_;
class EngineOnOff;
struct EngineOnOffDefaultTypeInternal;
extern EngineOnOffDefaultTypeInternal _EngineOnOff_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventAck;
struct EventAckDefaultTypeInternal;
extern EventAckDefaultTypeInternal _EventAck_default_instance_;
class EventMsg;
struct EventMsgDefaultTypeInternal;
extern EventMsgDefaultTypeInternal _EventMsg_default_instance_;
class LampInfo;
struct LampInfoDefaultTypeInternal;
extern LampInfoDefaultTypeInternal _LampInfo_default_instance_;
class SKFaultInfo;
struct SKFaultInfoDefaultTypeInternal;
extern SKFaultInfoDefaultTypeInternal _SKFaultInfo_default_instance_;
class SeatBucketOpenClose;
struct SeatBucketOpenCloseDefaultTypeInternal;
extern SeatBucketOpenCloseDefaultTypeInternal _SeatBucketOpenClose_default_instance_;
class SideStandInfo;
struct SideStandInfoDefaultTypeInternal;
extern SideStandInfoDefaultTypeInternal _SideStandInfo_default_instance_;
}  // namespace EventNS
PROTOBUF_NAMESPACE_OPEN
template<> ::EventNS::BatteryInfo* Arena::CreateMaybeMessage<::EventNS::BatteryInfo>(Arena*);
template<> ::EventNS::BluetoothInfo* Arena::CreateMaybeMessage<::EventNS::BluetoothInfo>(Arena*);
template<> ::EventNS::EngineOnOff* Arena::CreateMaybeMessage<::EventNS::EngineOnOff>(Arena*);
template<> ::EventNS::Event* Arena::CreateMaybeMessage<::EventNS::Event>(Arena*);
template<> ::EventNS::EventAck* Arena::CreateMaybeMessage<::EventNS::EventAck>(Arena*);
template<> ::EventNS::EventMsg* Arena::CreateMaybeMessage<::EventNS::EventMsg>(Arena*);
template<> ::EventNS::LampInfo* Arena::CreateMaybeMessage<::EventNS::LampInfo>(Arena*);
template<> ::EventNS::SKFaultInfo* Arena::CreateMaybeMessage<::EventNS::SKFaultInfo>(Arena*);
template<> ::EventNS::SeatBucketOpenClose* Arena::CreateMaybeMessage<::EventNS::SeatBucketOpenClose>(Arena*);
template<> ::EventNS::SideStandInfo* Arena::CreateMaybeMessage<::EventNS::SideStandInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace EventNS {

enum SideStandStatus : int {
  LOWER = 0,
  RAISE = 1,
  SideStandStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SideStandStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SideStandStatus_IsValid(int value);
constexpr SideStandStatus SideStandStatus_MIN = LOWER;
constexpr SideStandStatus SideStandStatus_MAX = RAISE;
constexpr int SideStandStatus_ARRAYSIZE = SideStandStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SideStandStatus_descriptor();
template<typename T>
inline const std::string& SideStandStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SideStandStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SideStandStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SideStandStatus_descriptor(), enum_t_value);
}
inline bool SideStandStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SideStandStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SideStandStatus>(
    SideStandStatus_descriptor(), name, value);
}
enum LampType : int {
  LOW_BEAM_LIGHT = 0,
  HIGH_BEAM_LIGHT = 1,
  DAY_TIME_RUNNING_LIGHT = 2,
  BACK_POSITION_LIGHT = 3,
  LICENSE_PLATE_LIGHT = 4,
  LampType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LampType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LampType_IsValid(int value);
constexpr LampType LampType_MIN = LOW_BEAM_LIGHT;
constexpr LampType LampType_MAX = LICENSE_PLATE_LIGHT;
constexpr int LampType_ARRAYSIZE = LampType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LampType_descriptor();
template<typename T>
inline const std::string& LampType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LampType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LampType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LampType_descriptor(), enum_t_value);
}
inline bool LampType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LampType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LampType>(
    LampType_descriptor(), name, value);
}
enum LampStatus : int {
  OFF = 0,
  ON = 1,
  CHARGING = 2,
  LampStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LampStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LampStatus_IsValid(int value);
constexpr LampStatus LampStatus_MIN = OFF;
constexpr LampStatus LampStatus_MAX = CHARGING;
constexpr int LampStatus_ARRAYSIZE = LampStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LampStatus_descriptor();
template<typename T>
inline const std::string& LampStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LampStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LampStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LampStatus_descriptor(), enum_t_value);
}
inline bool LampStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LampStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LampStatus>(
    LampStatus_descriptor(), name, value);
}
enum SeatBucketStatus : int {
  OPEN = 0,
  CLOSE = 1,
  SeatBucketStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeatBucketStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SeatBucketStatus_IsValid(int value);
constexpr SeatBucketStatus SeatBucketStatus_MIN = OPEN;
constexpr SeatBucketStatus SeatBucketStatus_MAX = CLOSE;
constexpr int SeatBucketStatus_ARRAYSIZE = SeatBucketStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeatBucketStatus_descriptor();
template<typename T>
inline const std::string& SeatBucketStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeatBucketStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeatBucketStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeatBucketStatus_descriptor(), enum_t_value);
}
inline bool SeatBucketStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeatBucketStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeatBucketStatus>(
    SeatBucketStatus_descriptor(), name, value);
}
enum EventItem : int {
  INVALID = 0,
  ENGINE_ON_OFF = 1,
  GEAR_POSITION = 2,
  BATTERY_QTY = 3,
  SK_FAULT = 4,
  SIDE_STAND_LOWER_RAISE = 5,
  LAMP_ON_OFF = 6,
  SEAT_BUCKET_OPEN_CLOSE = 7,
  EventItem_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventItem_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventItem_IsValid(int value);
constexpr EventItem EventItem_MIN = INVALID;
constexpr EventItem EventItem_MAX = SEAT_BUCKET_OPEN_CLOSE;
constexpr int EventItem_ARRAYSIZE = EventItem_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventItem_descriptor();
template<typename T>
inline const std::string& EventItem_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventItem>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventItem_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventItem_descriptor(), enum_t_value);
}
inline bool EventItem_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventItem* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventItem>(
    EventItem_descriptor(), name, value);
}
// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMsgFieldNumber = 1,
    kEventAckFieldNumber = 2,
  };
  // repeated .EventNS.EventMsg eventMsg = 1;
  int eventmsg_size() const;
  private:
  int _internal_eventmsg_size() const;
  public:
  void clear_eventmsg();
  ::EventNS::EventMsg* mutable_eventmsg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::EventMsg >*
      mutable_eventmsg();
  private:
  const ::EventNS::EventMsg& _internal_eventmsg(int index) const;
  ::EventNS::EventMsg* _internal_add_eventmsg();
  public:
  const ::EventNS::EventMsg& eventmsg(int index) const;
  ::EventNS::EventMsg* add_eventmsg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::EventMsg >&
      eventmsg() const;

  // .EventNS.EventAck eventAck = 2;
  bool has_eventack() const;
  private:
  bool _internal_has_eventack() const;
  public:
  void clear_eventack();
  const ::EventNS::EventAck& eventack() const;
  PROTOBUF_NODISCARD ::EventNS::EventAck* release_eventack();
  ::EventNS::EventAck* mutable_eventack();
  void set_allocated_eventack(::EventNS::EventAck* eventack);
  private:
  const ::EventNS::EventAck& _internal_eventack() const;
  ::EventNS::EventAck* _internal_mutable_eventack();
  public:
  void unsafe_arena_set_allocated_eventack(
      ::EventNS::EventAck* eventack);
  ::EventNS::EventAck* unsafe_arena_release_eventack();

  // @@protoc_insertion_point(class_scope:EventNS.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::EventMsg > eventmsg_;
  ::EventNS::EventAck* eventack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class EventMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.EventMsg) */ {
 public:
  inline EventMsg() : EventMsg(nullptr) {}
  ~EventMsg() override;
  explicit constexpr EventMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventMsg(const EventMsg& from);
  EventMsg(EventMsg&& from) noexcept
    : EventMsg() {
    *this = ::std::move(from);
  }

  inline EventMsg& operator=(const EventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventMsg& operator=(EventMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventMsg* internal_default_instance() {
    return reinterpret_cast<const EventMsg*>(
               &_EventMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EventMsg& a, EventMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(EventMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.EventMsg";
  }
  protected:
  explicit EventMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryInfoFieldNumber = 4,
    kLampsFieldNumber = 7,
    kEngineOnOffFieldNumber = 2,
    kSkFaultInfoFieldNumber = 5,
    kSideStandInfoFieldNumber = 6,
    kSeatBucketOpenCloseFieldNumber = 8,
    kEventItemFieldNumber = 1,
    kGearPositionFieldNumber = 3,
  };
  // repeated .EventNS.BatteryInfo batteryInfo = 4;
  int batteryinfo_size() const;
  private:
  int _internal_batteryinfo_size() const;
  public:
  void clear_batteryinfo();
  ::EventNS::BatteryInfo* mutable_batteryinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::BatteryInfo >*
      mutable_batteryinfo();
  private:
  const ::EventNS::BatteryInfo& _internal_batteryinfo(int index) const;
  ::EventNS::BatteryInfo* _internal_add_batteryinfo();
  public:
  const ::EventNS::BatteryInfo& batteryinfo(int index) const;
  ::EventNS::BatteryInfo* add_batteryinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::BatteryInfo >&
      batteryinfo() const;

  // repeated .EventNS.LampInfo lamps = 7;
  int lamps_size() const;
  private:
  int _internal_lamps_size() const;
  public:
  void clear_lamps();
  ::EventNS::LampInfo* mutable_lamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::LampInfo >*
      mutable_lamps();
  private:
  const ::EventNS::LampInfo& _internal_lamps(int index) const;
  ::EventNS::LampInfo* _internal_add_lamps();
  public:
  const ::EventNS::LampInfo& lamps(int index) const;
  ::EventNS::LampInfo* add_lamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::LampInfo >&
      lamps() const;

  // .EventNS.EngineOnOff engineOnOff = 2;
  bool has_engineonoff() const;
  private:
  bool _internal_has_engineonoff() const;
  public:
  void clear_engineonoff();
  const ::EventNS::EngineOnOff& engineonoff() const;
  PROTOBUF_NODISCARD ::EventNS::EngineOnOff* release_engineonoff();
  ::EventNS::EngineOnOff* mutable_engineonoff();
  void set_allocated_engineonoff(::EventNS::EngineOnOff* engineonoff);
  private:
  const ::EventNS::EngineOnOff& _internal_engineonoff() const;
  ::EventNS::EngineOnOff* _internal_mutable_engineonoff();
  public:
  void unsafe_arena_set_allocated_engineonoff(
      ::EventNS::EngineOnOff* engineonoff);
  ::EventNS::EngineOnOff* unsafe_arena_release_engineonoff();

  // .EventNS.SKFaultInfo skFaultInfo = 5;
  bool has_skfaultinfo() const;
  private:
  bool _internal_has_skfaultinfo() const;
  public:
  void clear_skfaultinfo();
  const ::EventNS::SKFaultInfo& skfaultinfo() const;
  PROTOBUF_NODISCARD ::EventNS::SKFaultInfo* release_skfaultinfo();
  ::EventNS::SKFaultInfo* mutable_skfaultinfo();
  void set_allocated_skfaultinfo(::EventNS::SKFaultInfo* skfaultinfo);
  private:
  const ::EventNS::SKFaultInfo& _internal_skfaultinfo() const;
  ::EventNS::SKFaultInfo* _internal_mutable_skfaultinfo();
  public:
  void unsafe_arena_set_allocated_skfaultinfo(
      ::EventNS::SKFaultInfo* skfaultinfo);
  ::EventNS::SKFaultInfo* unsafe_arena_release_skfaultinfo();

  // .EventNS.SideStandInfo sideStandInfo = 6;
  bool has_sidestandinfo() const;
  private:
  bool _internal_has_sidestandinfo() const;
  public:
  void clear_sidestandinfo();
  const ::EventNS::SideStandInfo& sidestandinfo() const;
  PROTOBUF_NODISCARD ::EventNS::SideStandInfo* release_sidestandinfo();
  ::EventNS::SideStandInfo* mutable_sidestandinfo();
  void set_allocated_sidestandinfo(::EventNS::SideStandInfo* sidestandinfo);
  private:
  const ::EventNS::SideStandInfo& _internal_sidestandinfo() const;
  ::EventNS::SideStandInfo* _internal_mutable_sidestandinfo();
  public:
  void unsafe_arena_set_allocated_sidestandinfo(
      ::EventNS::SideStandInfo* sidestandinfo);
  ::EventNS::SideStandInfo* unsafe_arena_release_sidestandinfo();

  // .EventNS.SeatBucketOpenClose seatBucketOpenClose = 8;
  bool has_seatbucketopenclose() const;
  private:
  bool _internal_has_seatbucketopenclose() const;
  public:
  void clear_seatbucketopenclose();
  const ::EventNS::SeatBucketOpenClose& seatbucketopenclose() const;
  PROTOBUF_NODISCARD ::EventNS::SeatBucketOpenClose* release_seatbucketopenclose();
  ::EventNS::SeatBucketOpenClose* mutable_seatbucketopenclose();
  void set_allocated_seatbucketopenclose(::EventNS::SeatBucketOpenClose* seatbucketopenclose);
  private:
  const ::EventNS::SeatBucketOpenClose& _internal_seatbucketopenclose() const;
  ::EventNS::SeatBucketOpenClose* _internal_mutable_seatbucketopenclose();
  public:
  void unsafe_arena_set_allocated_seatbucketopenclose(
      ::EventNS::SeatBucketOpenClose* seatbucketopenclose);
  ::EventNS::SeatBucketOpenClose* unsafe_arena_release_seatbucketopenclose();

  // .EventNS.EventItem eventItem = 1;
  void clear_eventitem();
  ::EventNS::EventItem eventitem() const;
  void set_eventitem(::EventNS::EventItem value);
  private:
  ::EventNS::EventItem _internal_eventitem() const;
  void _internal_set_eventitem(::EventNS::EventItem value);
  public:

  // .StatusNS.GearPosition gearPosition = 3;
  void clear_gearposition();
  ::StatusNS::GearPosition gearposition() const;
  void set_gearposition(::StatusNS::GearPosition value);
  private:
  ::StatusNS::GearPosition _internal_gearposition() const;
  void _internal_set_gearposition(::StatusNS::GearPosition value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.EventMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::BatteryInfo > batteryinfo_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::LampInfo > lamps_;
  ::EventNS::EngineOnOff* engineonoff_;
  ::EventNS::SKFaultInfo* skfaultinfo_;
  ::EventNS::SideStandInfo* sidestandinfo_;
  ::EventNS::SeatBucketOpenClose* seatbucketopenclose_;
  int eventitem_;
  int gearposition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class EngineOnOff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.EngineOnOff) */ {
 public:
  inline EngineOnOff() : EngineOnOff(nullptr) {}
  ~EngineOnOff() override;
  explicit constexpr EngineOnOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineOnOff(const EngineOnOff& from);
  EngineOnOff(EngineOnOff&& from) noexcept
    : EngineOnOff() {
    *this = ::std::move(from);
  }

  inline EngineOnOff& operator=(const EngineOnOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineOnOff& operator=(EngineOnOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineOnOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineOnOff* internal_default_instance() {
    return reinterpret_cast<const EngineOnOff*>(
               &_EngineOnOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EngineOnOff& a, EngineOnOff& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineOnOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineOnOff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineOnOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EngineOnOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EngineOnOff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EngineOnOff& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineOnOff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.EngineOnOff";
  }
  protected:
  explicit EngineOnOff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kTaskIDFieldNumber = 6,
    kHmiInfoFieldNumber = 3,
    kBluetoothInfoFieldNumber = 4,
    kKl15FieldNumber = 1,
    kPowerFieldNumber = 5,
  };
  // bytes location = 2;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string taskID = 6;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // .StatusNS.HmiInfo hmiInfo = 3;
  bool has_hmiinfo() const;
  private:
  bool _internal_has_hmiinfo() const;
  public:
  void clear_hmiinfo();
  const ::StatusNS::HmiInfo& hmiinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::HmiInfo* release_hmiinfo();
  ::StatusNS::HmiInfo* mutable_hmiinfo();
  void set_allocated_hmiinfo(::StatusNS::HmiInfo* hmiinfo);
  private:
  const ::StatusNS::HmiInfo& _internal_hmiinfo() const;
  ::StatusNS::HmiInfo* _internal_mutable_hmiinfo();
  public:
  void unsafe_arena_set_allocated_hmiinfo(
      ::StatusNS::HmiInfo* hmiinfo);
  ::StatusNS::HmiInfo* unsafe_arena_release_hmiinfo();

  // .EventNS.BluetoothInfo bluetoothInfo = 4;
  bool has_bluetoothinfo() const;
  private:
  bool _internal_has_bluetoothinfo() const;
  public:
  void clear_bluetoothinfo();
  const ::EventNS::BluetoothInfo& bluetoothinfo() const;
  PROTOBUF_NODISCARD ::EventNS::BluetoothInfo* release_bluetoothinfo();
  ::EventNS::BluetoothInfo* mutable_bluetoothinfo();
  void set_allocated_bluetoothinfo(::EventNS::BluetoothInfo* bluetoothinfo);
  private:
  const ::EventNS::BluetoothInfo& _internal_bluetoothinfo() const;
  ::EventNS::BluetoothInfo* _internal_mutable_bluetoothinfo();
  public:
  void unsafe_arena_set_allocated_bluetoothinfo(
      ::EventNS::BluetoothInfo* bluetoothinfo);
  ::EventNS::BluetoothInfo* unsafe_arena_release_bluetoothinfo();

  // bool kl15 = 1;
  void clear_kl15();
  bool kl15() const;
  void set_kl15(bool value);
  private:
  bool _internal_kl15() const;
  void _internal_set_kl15(bool value);
  public:

  // uint32 power = 5;
  void clear_power();
  uint32_t power() const;
  void set_power(uint32_t value);
  private:
  uint32_t _internal_power() const;
  void _internal_set_power(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.EngineOnOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
  ::StatusNS::HmiInfo* hmiinfo_;
  ::EventNS::BluetoothInfo* bluetoothinfo_;
  bool kl15_;
  uint32_t power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class BluetoothInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.BluetoothInfo) */ {
 public:
  inline BluetoothInfo() : BluetoothInfo(nullptr) {}
  ~BluetoothInfo() override;
  explicit constexpr BluetoothInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BluetoothInfo(const BluetoothInfo& from);
  BluetoothInfo(BluetoothInfo&& from) noexcept
    : BluetoothInfo() {
    *this = ::std::move(from);
  }

  inline BluetoothInfo& operator=(const BluetoothInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothInfo& operator=(BluetoothInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BluetoothInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothInfo* internal_default_instance() {
    return reinterpret_cast<const BluetoothInfo*>(
               &_BluetoothInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BluetoothInfo& a, BluetoothInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BluetoothInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BluetoothInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BluetoothInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BluetoothInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.BluetoothInfo";
  }
  protected:
  explicit BluetoothInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBluetoothNameFieldNumber = 1,
    kBluetoothPwdFieldNumber = 2,
    kBluetoothSecretKeyFieldNumber = 3,
    kBluetoothMacFieldNumber = 4,
  };
  // string bluetoothName = 1;
  void clear_bluetoothname();
  const std::string& bluetoothname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bluetoothname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bluetoothname();
  PROTOBUF_NODISCARD std::string* release_bluetoothname();
  void set_allocated_bluetoothname(std::string* bluetoothname);
  private:
  const std::string& _internal_bluetoothname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bluetoothname(const std::string& value);
  std::string* _internal_mutable_bluetoothname();
  public:

  // string bluetoothPwd = 2;
  void clear_bluetoothpwd();
  const std::string& bluetoothpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bluetoothpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bluetoothpwd();
  PROTOBUF_NODISCARD std::string* release_bluetoothpwd();
  void set_allocated_bluetoothpwd(std::string* bluetoothpwd);
  private:
  const std::string& _internal_bluetoothpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bluetoothpwd(const std::string& value);
  std::string* _internal_mutable_bluetoothpwd();
  public:

  // string bluetoothSecretKey = 3;
  void clear_bluetoothsecretkey();
  const std::string& bluetoothsecretkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bluetoothsecretkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bluetoothsecretkey();
  PROTOBUF_NODISCARD std::string* release_bluetoothsecretkey();
  void set_allocated_bluetoothsecretkey(std::string* bluetoothsecretkey);
  private:
  const std::string& _internal_bluetoothsecretkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bluetoothsecretkey(const std::string& value);
  std::string* _internal_mutable_bluetoothsecretkey();
  public:

  // string bluetoothMac = 4;
  void clear_bluetoothmac();
  const std::string& bluetoothmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bluetoothmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bluetoothmac();
  PROTOBUF_NODISCARD std::string* release_bluetoothmac();
  void set_allocated_bluetoothmac(std::string* bluetoothmac);
  private:
  const std::string& _internal_bluetoothmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bluetoothmac(const std::string& value);
  std::string* _internal_mutable_bluetoothmac();
  public:

  // @@protoc_insertion_point(class_scope:EventNS.BluetoothInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bluetoothname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bluetoothpwd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bluetoothsecretkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bluetoothmac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class BatteryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.BatteryInfo) */ {
 public:
  inline BatteryInfo() : BatteryInfo(nullptr) {}
  ~BatteryInfo() override;
  explicit constexpr BatteryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryInfo(const BatteryInfo& from);
  BatteryInfo(BatteryInfo&& from) noexcept
    : BatteryInfo() {
    *this = ::std::move(from);
  }

  inline BatteryInfo& operator=(const BatteryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryInfo& operator=(BatteryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryInfo* internal_default_instance() {
    return reinterpret_cast<const BatteryInfo*>(
               &_BatteryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BatteryInfo& a, BatteryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatteryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatteryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatteryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatteryInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.BatteryInfo";
  }
  protected:
  explicit BatteryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChargingFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kRangeFieldNumber = 3,
    kTempFieldNumber = 4,
    kCycleFieldNumber = 5,
    kRemainingFieldNumber = 6,
    kBmsIdFieldNumber = 7,
  };
  // bool charging = 1;
  void clear_charging();
  bool charging() const;
  void set_charging(bool value);
  private:
  bool _internal_charging() const;
  void _internal_set_charging(bool value);
  public:

  // uint32 quantity = 2;
  void clear_quantity();
  uint32_t quantity() const;
  void set_quantity(uint32_t value);
  private:
  uint32_t _internal_quantity() const;
  void _internal_set_quantity(uint32_t value);
  public:

  // uint32 range = 3;
  void clear_range();
  uint32_t range() const;
  void set_range(uint32_t value);
  private:
  uint32_t _internal_range() const;
  void _internal_set_range(uint32_t value);
  public:

  // uint32 temp = 4;
  void clear_temp();
  uint32_t temp() const;
  void set_temp(uint32_t value);
  private:
  uint32_t _internal_temp() const;
  void _internal_set_temp(uint32_t value);
  public:

  // uint32 cycle = 5;
  void clear_cycle();
  uint32_t cycle() const;
  void set_cycle(uint32_t value);
  private:
  uint32_t _internal_cycle() const;
  void _internal_set_cycle(uint32_t value);
  public:

  // uint32 remaining = 6;
  void clear_remaining();
  uint32_t remaining() const;
  void set_remaining(uint32_t value);
  private:
  uint32_t _internal_remaining() const;
  void _internal_set_remaining(uint32_t value);
  public:

  // uint32 bmsId = 7;
  void clear_bmsid();
  uint32_t bmsid() const;
  void set_bmsid(uint32_t value);
  private:
  uint32_t _internal_bmsid() const;
  void _internal_set_bmsid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.BatteryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool charging_;
  uint32_t quantity_;
  uint32_t range_;
  uint32_t temp_;
  uint32_t cycle_;
  uint32_t remaining_;
  uint32_t bmsid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class SKFaultInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.SKFaultInfo) */ {
 public:
  inline SKFaultInfo() : SKFaultInfo(nullptr) {}
  ~SKFaultInfo() override;
  explicit constexpr SKFaultInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SKFaultInfo(const SKFaultInfo& from);
  SKFaultInfo(SKFaultInfo&& from) noexcept
    : SKFaultInfo() {
    *this = ::std::move(from);
  }

  inline SKFaultInfo& operator=(const SKFaultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SKFaultInfo& operator=(SKFaultInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SKFaultInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SKFaultInfo* internal_default_instance() {
    return reinterpret_cast<const SKFaultInfo*>(
               &_SKFaultInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SKFaultInfo& a, SKFaultInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SKFaultInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SKFaultInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SKFaultInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SKFaultInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SKFaultInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SKFaultInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SKFaultInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.SKFaultInfo";
  }
  protected:
  explicit SKFaultInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMcuFaultFieldNumber = 1,
    kBmsFaultFieldNumber = 2,
  };
  // bytes mcuFault = 1;
  void clear_mcufault();
  const std::string& mcufault() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcufault(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcufault();
  PROTOBUF_NODISCARD std::string* release_mcufault();
  void set_allocated_mcufault(std::string* mcufault);
  private:
  const std::string& _internal_mcufault() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcufault(const std::string& value);
  std::string* _internal_mutable_mcufault();
  public:

  // bytes bmsFault = 2;
  void clear_bmsfault();
  const std::string& bmsfault() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bmsfault(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bmsfault();
  PROTOBUF_NODISCARD std::string* release_bmsfault();
  void set_allocated_bmsfault(std::string* bmsfault);
  private:
  const std::string& _internal_bmsfault() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bmsfault(const std::string& value);
  std::string* _internal_mutable_bmsfault();
  public:

  // @@protoc_insertion_point(class_scope:EventNS.SKFaultInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcufault_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bmsfault_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class SideStandInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.SideStandInfo) */ {
 public:
  inline SideStandInfo() : SideStandInfo(nullptr) {}
  ~SideStandInfo() override;
  explicit constexpr SideStandInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SideStandInfo(const SideStandInfo& from);
  SideStandInfo(SideStandInfo&& from) noexcept
    : SideStandInfo() {
    *this = ::std::move(from);
  }

  inline SideStandInfo& operator=(const SideStandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SideStandInfo& operator=(SideStandInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SideStandInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SideStandInfo* internal_default_instance() {
    return reinterpret_cast<const SideStandInfo*>(
               &_SideStandInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SideStandInfo& a, SideStandInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SideStandInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SideStandInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SideStandInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SideStandInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SideStandInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SideStandInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SideStandInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.SideStandInfo";
  }
  protected:
  explicit SideStandInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .EventNS.SideStandStatus status = 1;
  void clear_status();
  ::EventNS::SideStandStatus status() const;
  void set_status(::EventNS::SideStandStatus value);
  private:
  ::EventNS::SideStandStatus _internal_status() const;
  void _internal_set_status(::EventNS::SideStandStatus value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.SideStandInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class LampInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.LampInfo) */ {
 public:
  inline LampInfo() : LampInfo(nullptr) {}
  ~LampInfo() override;
  explicit constexpr LampInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LampInfo(const LampInfo& from);
  LampInfo(LampInfo&& from) noexcept
    : LampInfo() {
    *this = ::std::move(from);
  }

  inline LampInfo& operator=(const LampInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LampInfo& operator=(LampInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LampInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LampInfo* internal_default_instance() {
    return reinterpret_cast<const LampInfo*>(
               &_LampInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LampInfo& a, LampInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LampInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LampInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LampInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LampInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LampInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LampInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LampInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.LampInfo";
  }
  protected:
  explicit LampInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLampTypeFieldNumber = 1,
    kLampStatusFieldNumber = 2,
  };
  // .EventNS.LampType lampType = 1;
  void clear_lamptype();
  ::EventNS::LampType lamptype() const;
  void set_lamptype(::EventNS::LampType value);
  private:
  ::EventNS::LampType _internal_lamptype() const;
  void _internal_set_lamptype(::EventNS::LampType value);
  public:

  // .EventNS.LampStatus lampStatus = 2;
  void clear_lampstatus();
  ::EventNS::LampStatus lampstatus() const;
  void set_lampstatus(::EventNS::LampStatus value);
  private:
  ::EventNS::LampStatus _internal_lampstatus() const;
  void _internal_set_lampstatus(::EventNS::LampStatus value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.LampInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int lamptype_;
  int lampstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class SeatBucketOpenClose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.SeatBucketOpenClose) */ {
 public:
  inline SeatBucketOpenClose() : SeatBucketOpenClose(nullptr) {}
  ~SeatBucketOpenClose() override;
  explicit constexpr SeatBucketOpenClose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeatBucketOpenClose(const SeatBucketOpenClose& from);
  SeatBucketOpenClose(SeatBucketOpenClose&& from) noexcept
    : SeatBucketOpenClose() {
    *this = ::std::move(from);
  }

  inline SeatBucketOpenClose& operator=(const SeatBucketOpenClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeatBucketOpenClose& operator=(SeatBucketOpenClose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeatBucketOpenClose& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeatBucketOpenClose* internal_default_instance() {
    return reinterpret_cast<const SeatBucketOpenClose*>(
               &_SeatBucketOpenClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SeatBucketOpenClose& a, SeatBucketOpenClose& b) {
    a.Swap(&b);
  }
  inline void Swap(SeatBucketOpenClose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeatBucketOpenClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeatBucketOpenClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeatBucketOpenClose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeatBucketOpenClose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SeatBucketOpenClose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatBucketOpenClose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.SeatBucketOpenClose";
  }
  protected:
  explicit SeatBucketOpenClose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .EventNS.SeatBucketStatus status = 1;
  void clear_status();
  ::EventNS::SeatBucketStatus status() const;
  void set_status(::EventNS::SeatBucketStatus value);
  private:
  ::EventNS::SeatBucketStatus _internal_status() const;
  void _internal_set_status(::EventNS::SeatBucketStatus value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.SeatBucketOpenClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// -------------------------------------------------------------------

class EventAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventNS.EventAck) */ {
 public:
  inline EventAck() : EventAck(nullptr) {}
  ~EventAck() override;
  explicit constexpr EventAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAck(const EventAck& from);
  EventAck(EventAck&& from) noexcept
    : EventAck() {
    *this = ::std::move(from);
  }

  inline EventAck& operator=(const EventAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAck& operator=(EventAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAck* internal_default_instance() {
    return reinterpret_cast<const EventAck*>(
               &_EventAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EventAck& a, EventAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventNS.EventAck";
  }
  protected:
  explicit EventAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIDFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string taskID = 2;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EventNS.EventAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
  uint32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_event_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// repeated .EventNS.EventMsg eventMsg = 1;
inline int Event::_internal_eventmsg_size() const {
  return eventmsg_.size();
}
inline int Event::eventmsg_size() const {
  return _internal_eventmsg_size();
}
inline void Event::clear_eventmsg() {
  eventmsg_.Clear();
}
inline ::EventNS::EventMsg* Event::mutable_eventmsg(int index) {
  // @@protoc_insertion_point(field_mutable:EventNS.Event.eventMsg)
  return eventmsg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::EventMsg >*
Event::mutable_eventmsg() {
  // @@protoc_insertion_point(field_mutable_list:EventNS.Event.eventMsg)
  return &eventmsg_;
}
inline const ::EventNS::EventMsg& Event::_internal_eventmsg(int index) const {
  return eventmsg_.Get(index);
}
inline const ::EventNS::EventMsg& Event::eventmsg(int index) const {
  // @@protoc_insertion_point(field_get:EventNS.Event.eventMsg)
  return _internal_eventmsg(index);
}
inline ::EventNS::EventMsg* Event::_internal_add_eventmsg() {
  return eventmsg_.Add();
}
inline ::EventNS::EventMsg* Event::add_eventmsg() {
  ::EventNS::EventMsg* _add = _internal_add_eventmsg();
  // @@protoc_insertion_point(field_add:EventNS.Event.eventMsg)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::EventMsg >&
Event::eventmsg() const {
  // @@protoc_insertion_point(field_list:EventNS.Event.eventMsg)
  return eventmsg_;
}

// .EventNS.EventAck eventAck = 2;
inline bool Event::_internal_has_eventack() const {
  return this != internal_default_instance() && eventack_ != nullptr;
}
inline bool Event::has_eventack() const {
  return _internal_has_eventack();
}
inline void Event::clear_eventack() {
  if (GetArenaForAllocation() == nullptr && eventack_ != nullptr) {
    delete eventack_;
  }
  eventack_ = nullptr;
}
inline const ::EventNS::EventAck& Event::_internal_eventack() const {
  const ::EventNS::EventAck* p = eventack_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::EventAck&>(
      ::EventNS::_EventAck_default_instance_);
}
inline const ::EventNS::EventAck& Event::eventack() const {
  // @@protoc_insertion_point(field_get:EventNS.Event.eventAck)
  return _internal_eventack();
}
inline void Event::unsafe_arena_set_allocated_eventack(
    ::EventNS::EventAck* eventack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventack_);
  }
  eventack_ = eventack;
  if (eventack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.Event.eventAck)
}
inline ::EventNS::EventAck* Event::release_eventack() {
  
  ::EventNS::EventAck* temp = eventack_;
  eventack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::EventAck* Event::unsafe_arena_release_eventack() {
  // @@protoc_insertion_point(field_release:EventNS.Event.eventAck)
  
  ::EventNS::EventAck* temp = eventack_;
  eventack_ = nullptr;
  return temp;
}
inline ::EventNS::EventAck* Event::_internal_mutable_eventack() {
  
  if (eventack_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::EventAck>(GetArenaForAllocation());
    eventack_ = p;
  }
  return eventack_;
}
inline ::EventNS::EventAck* Event::mutable_eventack() {
  ::EventNS::EventAck* _msg = _internal_mutable_eventack();
  // @@protoc_insertion_point(field_mutable:EventNS.Event.eventAck)
  return _msg;
}
inline void Event::set_allocated_eventack(::EventNS::EventAck* eventack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete eventack_;
  }
  if (eventack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::EventAck>::GetOwningArena(eventack);
    if (message_arena != submessage_arena) {
      eventack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventack, submessage_arena);
    }
    
  } else {
    
  }
  eventack_ = eventack;
  // @@protoc_insertion_point(field_set_allocated:EventNS.Event.eventAck)
}

// -------------------------------------------------------------------

// EventMsg

// .EventNS.EventItem eventItem = 1;
inline void EventMsg::clear_eventitem() {
  eventitem_ = 0;
}
inline ::EventNS::EventItem EventMsg::_internal_eventitem() const {
  return static_cast< ::EventNS::EventItem >(eventitem_);
}
inline ::EventNS::EventItem EventMsg::eventitem() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.eventItem)
  return _internal_eventitem();
}
inline void EventMsg::_internal_set_eventitem(::EventNS::EventItem value) {
  
  eventitem_ = value;
}
inline void EventMsg::set_eventitem(::EventNS::EventItem value) {
  _internal_set_eventitem(value);
  // @@protoc_insertion_point(field_set:EventNS.EventMsg.eventItem)
}

// .EventNS.EngineOnOff engineOnOff = 2;
inline bool EventMsg::_internal_has_engineonoff() const {
  return this != internal_default_instance() && engineonoff_ != nullptr;
}
inline bool EventMsg::has_engineonoff() const {
  return _internal_has_engineonoff();
}
inline void EventMsg::clear_engineonoff() {
  if (GetArenaForAllocation() == nullptr && engineonoff_ != nullptr) {
    delete engineonoff_;
  }
  engineonoff_ = nullptr;
}
inline const ::EventNS::EngineOnOff& EventMsg::_internal_engineonoff() const {
  const ::EventNS::EngineOnOff* p = engineonoff_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::EngineOnOff&>(
      ::EventNS::_EngineOnOff_default_instance_);
}
inline const ::EventNS::EngineOnOff& EventMsg::engineonoff() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.engineOnOff)
  return _internal_engineonoff();
}
inline void EventMsg::unsafe_arena_set_allocated_engineonoff(
    ::EventNS::EngineOnOff* engineonoff) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engineonoff_);
  }
  engineonoff_ = engineonoff;
  if (engineonoff) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EventMsg.engineOnOff)
}
inline ::EventNS::EngineOnOff* EventMsg::release_engineonoff() {
  
  ::EventNS::EngineOnOff* temp = engineonoff_;
  engineonoff_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::EngineOnOff* EventMsg::unsafe_arena_release_engineonoff() {
  // @@protoc_insertion_point(field_release:EventNS.EventMsg.engineOnOff)
  
  ::EventNS::EngineOnOff* temp = engineonoff_;
  engineonoff_ = nullptr;
  return temp;
}
inline ::EventNS::EngineOnOff* EventMsg::_internal_mutable_engineonoff() {
  
  if (engineonoff_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::EngineOnOff>(GetArenaForAllocation());
    engineonoff_ = p;
  }
  return engineonoff_;
}
inline ::EventNS::EngineOnOff* EventMsg::mutable_engineonoff() {
  ::EventNS::EngineOnOff* _msg = _internal_mutable_engineonoff();
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.engineOnOff)
  return _msg;
}
inline void EventMsg::set_allocated_engineonoff(::EventNS::EngineOnOff* engineonoff) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete engineonoff_;
  }
  if (engineonoff) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::EngineOnOff>::GetOwningArena(engineonoff);
    if (message_arena != submessage_arena) {
      engineonoff = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engineonoff, submessage_arena);
    }
    
  } else {
    
  }
  engineonoff_ = engineonoff;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EventMsg.engineOnOff)
}

// .StatusNS.GearPosition gearPosition = 3;
inline void EventMsg::clear_gearposition() {
  gearposition_ = 0;
}
inline ::StatusNS::GearPosition EventMsg::_internal_gearposition() const {
  return static_cast< ::StatusNS::GearPosition >(gearposition_);
}
inline ::StatusNS::GearPosition EventMsg::gearposition() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.gearPosition)
  return _internal_gearposition();
}
inline void EventMsg::_internal_set_gearposition(::StatusNS::GearPosition value) {
  
  gearposition_ = value;
}
inline void EventMsg::set_gearposition(::StatusNS::GearPosition value) {
  _internal_set_gearposition(value);
  // @@protoc_insertion_point(field_set:EventNS.EventMsg.gearPosition)
}

// repeated .EventNS.BatteryInfo batteryInfo = 4;
inline int EventMsg::_internal_batteryinfo_size() const {
  return batteryinfo_.size();
}
inline int EventMsg::batteryinfo_size() const {
  return _internal_batteryinfo_size();
}
inline void EventMsg::clear_batteryinfo() {
  batteryinfo_.Clear();
}
inline ::EventNS::BatteryInfo* EventMsg::mutable_batteryinfo(int index) {
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.batteryInfo)
  return batteryinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::BatteryInfo >*
EventMsg::mutable_batteryinfo() {
  // @@protoc_insertion_point(field_mutable_list:EventNS.EventMsg.batteryInfo)
  return &batteryinfo_;
}
inline const ::EventNS::BatteryInfo& EventMsg::_internal_batteryinfo(int index) const {
  return batteryinfo_.Get(index);
}
inline const ::EventNS::BatteryInfo& EventMsg::batteryinfo(int index) const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.batteryInfo)
  return _internal_batteryinfo(index);
}
inline ::EventNS::BatteryInfo* EventMsg::_internal_add_batteryinfo() {
  return batteryinfo_.Add();
}
inline ::EventNS::BatteryInfo* EventMsg::add_batteryinfo() {
  ::EventNS::BatteryInfo* _add = _internal_add_batteryinfo();
  // @@protoc_insertion_point(field_add:EventNS.EventMsg.batteryInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::BatteryInfo >&
EventMsg::batteryinfo() const {
  // @@protoc_insertion_point(field_list:EventNS.EventMsg.batteryInfo)
  return batteryinfo_;
}

// .EventNS.SKFaultInfo skFaultInfo = 5;
inline bool EventMsg::_internal_has_skfaultinfo() const {
  return this != internal_default_instance() && skfaultinfo_ != nullptr;
}
inline bool EventMsg::has_skfaultinfo() const {
  return _internal_has_skfaultinfo();
}
inline void EventMsg::clear_skfaultinfo() {
  if (GetArenaForAllocation() == nullptr && skfaultinfo_ != nullptr) {
    delete skfaultinfo_;
  }
  skfaultinfo_ = nullptr;
}
inline const ::EventNS::SKFaultInfo& EventMsg::_internal_skfaultinfo() const {
  const ::EventNS::SKFaultInfo* p = skfaultinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::SKFaultInfo&>(
      ::EventNS::_SKFaultInfo_default_instance_);
}
inline const ::EventNS::SKFaultInfo& EventMsg::skfaultinfo() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.skFaultInfo)
  return _internal_skfaultinfo();
}
inline void EventMsg::unsafe_arena_set_allocated_skfaultinfo(
    ::EventNS::SKFaultInfo* skfaultinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skfaultinfo_);
  }
  skfaultinfo_ = skfaultinfo;
  if (skfaultinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EventMsg.skFaultInfo)
}
inline ::EventNS::SKFaultInfo* EventMsg::release_skfaultinfo() {
  
  ::EventNS::SKFaultInfo* temp = skfaultinfo_;
  skfaultinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::SKFaultInfo* EventMsg::unsafe_arena_release_skfaultinfo() {
  // @@protoc_insertion_point(field_release:EventNS.EventMsg.skFaultInfo)
  
  ::EventNS::SKFaultInfo* temp = skfaultinfo_;
  skfaultinfo_ = nullptr;
  return temp;
}
inline ::EventNS::SKFaultInfo* EventMsg::_internal_mutable_skfaultinfo() {
  
  if (skfaultinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::SKFaultInfo>(GetArenaForAllocation());
    skfaultinfo_ = p;
  }
  return skfaultinfo_;
}
inline ::EventNS::SKFaultInfo* EventMsg::mutable_skfaultinfo() {
  ::EventNS::SKFaultInfo* _msg = _internal_mutable_skfaultinfo();
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.skFaultInfo)
  return _msg;
}
inline void EventMsg::set_allocated_skfaultinfo(::EventNS::SKFaultInfo* skfaultinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete skfaultinfo_;
  }
  if (skfaultinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::SKFaultInfo>::GetOwningArena(skfaultinfo);
    if (message_arena != submessage_arena) {
      skfaultinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skfaultinfo, submessage_arena);
    }
    
  } else {
    
  }
  skfaultinfo_ = skfaultinfo;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EventMsg.skFaultInfo)
}

// .EventNS.SideStandInfo sideStandInfo = 6;
inline bool EventMsg::_internal_has_sidestandinfo() const {
  return this != internal_default_instance() && sidestandinfo_ != nullptr;
}
inline bool EventMsg::has_sidestandinfo() const {
  return _internal_has_sidestandinfo();
}
inline void EventMsg::clear_sidestandinfo() {
  if (GetArenaForAllocation() == nullptr && sidestandinfo_ != nullptr) {
    delete sidestandinfo_;
  }
  sidestandinfo_ = nullptr;
}
inline const ::EventNS::SideStandInfo& EventMsg::_internal_sidestandinfo() const {
  const ::EventNS::SideStandInfo* p = sidestandinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::SideStandInfo&>(
      ::EventNS::_SideStandInfo_default_instance_);
}
inline const ::EventNS::SideStandInfo& EventMsg::sidestandinfo() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.sideStandInfo)
  return _internal_sidestandinfo();
}
inline void EventMsg::unsafe_arena_set_allocated_sidestandinfo(
    ::EventNS::SideStandInfo* sidestandinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sidestandinfo_);
  }
  sidestandinfo_ = sidestandinfo;
  if (sidestandinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EventMsg.sideStandInfo)
}
inline ::EventNS::SideStandInfo* EventMsg::release_sidestandinfo() {
  
  ::EventNS::SideStandInfo* temp = sidestandinfo_;
  sidestandinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::SideStandInfo* EventMsg::unsafe_arena_release_sidestandinfo() {
  // @@protoc_insertion_point(field_release:EventNS.EventMsg.sideStandInfo)
  
  ::EventNS::SideStandInfo* temp = sidestandinfo_;
  sidestandinfo_ = nullptr;
  return temp;
}
inline ::EventNS::SideStandInfo* EventMsg::_internal_mutable_sidestandinfo() {
  
  if (sidestandinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::SideStandInfo>(GetArenaForAllocation());
    sidestandinfo_ = p;
  }
  return sidestandinfo_;
}
inline ::EventNS::SideStandInfo* EventMsg::mutable_sidestandinfo() {
  ::EventNS::SideStandInfo* _msg = _internal_mutable_sidestandinfo();
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.sideStandInfo)
  return _msg;
}
inline void EventMsg::set_allocated_sidestandinfo(::EventNS::SideStandInfo* sidestandinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sidestandinfo_;
  }
  if (sidestandinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::SideStandInfo>::GetOwningArena(sidestandinfo);
    if (message_arena != submessage_arena) {
      sidestandinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sidestandinfo, submessage_arena);
    }
    
  } else {
    
  }
  sidestandinfo_ = sidestandinfo;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EventMsg.sideStandInfo)
}

// repeated .EventNS.LampInfo lamps = 7;
inline int EventMsg::_internal_lamps_size() const {
  return lamps_.size();
}
inline int EventMsg::lamps_size() const {
  return _internal_lamps_size();
}
inline void EventMsg::clear_lamps() {
  lamps_.Clear();
}
inline ::EventNS::LampInfo* EventMsg::mutable_lamps(int index) {
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.lamps)
  return lamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::LampInfo >*
EventMsg::mutable_lamps() {
  // @@protoc_insertion_point(field_mutable_list:EventNS.EventMsg.lamps)
  return &lamps_;
}
inline const ::EventNS::LampInfo& EventMsg::_internal_lamps(int index) const {
  return lamps_.Get(index);
}
inline const ::EventNS::LampInfo& EventMsg::lamps(int index) const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.lamps)
  return _internal_lamps(index);
}
inline ::EventNS::LampInfo* EventMsg::_internal_add_lamps() {
  return lamps_.Add();
}
inline ::EventNS::LampInfo* EventMsg::add_lamps() {
  ::EventNS::LampInfo* _add = _internal_add_lamps();
  // @@protoc_insertion_point(field_add:EventNS.EventMsg.lamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EventNS::LampInfo >&
EventMsg::lamps() const {
  // @@protoc_insertion_point(field_list:EventNS.EventMsg.lamps)
  return lamps_;
}

// .EventNS.SeatBucketOpenClose seatBucketOpenClose = 8;
inline bool EventMsg::_internal_has_seatbucketopenclose() const {
  return this != internal_default_instance() && seatbucketopenclose_ != nullptr;
}
inline bool EventMsg::has_seatbucketopenclose() const {
  return _internal_has_seatbucketopenclose();
}
inline void EventMsg::clear_seatbucketopenclose() {
  if (GetArenaForAllocation() == nullptr && seatbucketopenclose_ != nullptr) {
    delete seatbucketopenclose_;
  }
  seatbucketopenclose_ = nullptr;
}
inline const ::EventNS::SeatBucketOpenClose& EventMsg::_internal_seatbucketopenclose() const {
  const ::EventNS::SeatBucketOpenClose* p = seatbucketopenclose_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::SeatBucketOpenClose&>(
      ::EventNS::_SeatBucketOpenClose_default_instance_);
}
inline const ::EventNS::SeatBucketOpenClose& EventMsg::seatbucketopenclose() const {
  // @@protoc_insertion_point(field_get:EventNS.EventMsg.seatBucketOpenClose)
  return _internal_seatbucketopenclose();
}
inline void EventMsg::unsafe_arena_set_allocated_seatbucketopenclose(
    ::EventNS::SeatBucketOpenClose* seatbucketopenclose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(seatbucketopenclose_);
  }
  seatbucketopenclose_ = seatbucketopenclose;
  if (seatbucketopenclose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EventMsg.seatBucketOpenClose)
}
inline ::EventNS::SeatBucketOpenClose* EventMsg::release_seatbucketopenclose() {
  
  ::EventNS::SeatBucketOpenClose* temp = seatbucketopenclose_;
  seatbucketopenclose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::SeatBucketOpenClose* EventMsg::unsafe_arena_release_seatbucketopenclose() {
  // @@protoc_insertion_point(field_release:EventNS.EventMsg.seatBucketOpenClose)
  
  ::EventNS::SeatBucketOpenClose* temp = seatbucketopenclose_;
  seatbucketopenclose_ = nullptr;
  return temp;
}
inline ::EventNS::SeatBucketOpenClose* EventMsg::_internal_mutable_seatbucketopenclose() {
  
  if (seatbucketopenclose_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::SeatBucketOpenClose>(GetArenaForAllocation());
    seatbucketopenclose_ = p;
  }
  return seatbucketopenclose_;
}
inline ::EventNS::SeatBucketOpenClose* EventMsg::mutable_seatbucketopenclose() {
  ::EventNS::SeatBucketOpenClose* _msg = _internal_mutable_seatbucketopenclose();
  // @@protoc_insertion_point(field_mutable:EventNS.EventMsg.seatBucketOpenClose)
  return _msg;
}
inline void EventMsg::set_allocated_seatbucketopenclose(::EventNS::SeatBucketOpenClose* seatbucketopenclose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete seatbucketopenclose_;
  }
  if (seatbucketopenclose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::SeatBucketOpenClose>::GetOwningArena(seatbucketopenclose);
    if (message_arena != submessage_arena) {
      seatbucketopenclose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seatbucketopenclose, submessage_arena);
    }
    
  } else {
    
  }
  seatbucketopenclose_ = seatbucketopenclose;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EventMsg.seatBucketOpenClose)
}

// -------------------------------------------------------------------

// EngineOnOff

// bool kl15 = 1;
inline void EngineOnOff::clear_kl15() {
  kl15_ = false;
}
inline bool EngineOnOff::_internal_kl15() const {
  return kl15_;
}
inline bool EngineOnOff::kl15() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.kl15)
  return _internal_kl15();
}
inline void EngineOnOff::_internal_set_kl15(bool value) {
  
  kl15_ = value;
}
inline void EngineOnOff::set_kl15(bool value) {
  _internal_set_kl15(value);
  // @@protoc_insertion_point(field_set:EventNS.EngineOnOff.kl15)
}

// bytes location = 2;
inline void EngineOnOff::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& EngineOnOff::location() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EngineOnOff::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.EngineOnOff.location)
}
inline std::string* EngineOnOff::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:EventNS.EngineOnOff.location)
  return _s;
}
inline const std::string& EngineOnOff::_internal_location() const {
  return location_.Get();
}
inline void EngineOnOff::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EngineOnOff::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EngineOnOff::release_location() {
  // @@protoc_insertion_point(field_release:EventNS.EngineOnOff.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EngineOnOff::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.EngineOnOff.location)
}

// .StatusNS.HmiInfo hmiInfo = 3;
inline bool EngineOnOff::_internal_has_hmiinfo() const {
  return this != internal_default_instance() && hmiinfo_ != nullptr;
}
inline bool EngineOnOff::has_hmiinfo() const {
  return _internal_has_hmiinfo();
}
inline const ::StatusNS::HmiInfo& EngineOnOff::_internal_hmiinfo() const {
  const ::StatusNS::HmiInfo* p = hmiinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::HmiInfo&>(
      ::StatusNS::_HmiInfo_default_instance_);
}
inline const ::StatusNS::HmiInfo& EngineOnOff::hmiinfo() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.hmiInfo)
  return _internal_hmiinfo();
}
inline void EngineOnOff::unsafe_arena_set_allocated_hmiinfo(
    ::StatusNS::HmiInfo* hmiinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hmiinfo_);
  }
  hmiinfo_ = hmiinfo;
  if (hmiinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EngineOnOff.hmiInfo)
}
inline ::StatusNS::HmiInfo* EngineOnOff::release_hmiinfo() {
  
  ::StatusNS::HmiInfo* temp = hmiinfo_;
  hmiinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::HmiInfo* EngineOnOff::unsafe_arena_release_hmiinfo() {
  // @@protoc_insertion_point(field_release:EventNS.EngineOnOff.hmiInfo)
  
  ::StatusNS::HmiInfo* temp = hmiinfo_;
  hmiinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::HmiInfo* EngineOnOff::_internal_mutable_hmiinfo() {
  
  if (hmiinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::HmiInfo>(GetArenaForAllocation());
    hmiinfo_ = p;
  }
  return hmiinfo_;
}
inline ::StatusNS::HmiInfo* EngineOnOff::mutable_hmiinfo() {
  ::StatusNS::HmiInfo* _msg = _internal_mutable_hmiinfo();
  // @@protoc_insertion_point(field_mutable:EventNS.EngineOnOff.hmiInfo)
  return _msg;
}
inline void EngineOnOff::set_allocated_hmiinfo(::StatusNS::HmiInfo* hmiinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hmiinfo_);
  }
  if (hmiinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hmiinfo));
    if (message_arena != submessage_arena) {
      hmiinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hmiinfo, submessage_arena);
    }
    
  } else {
    
  }
  hmiinfo_ = hmiinfo;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EngineOnOff.hmiInfo)
}

// .EventNS.BluetoothInfo bluetoothInfo = 4;
inline bool EngineOnOff::_internal_has_bluetoothinfo() const {
  return this != internal_default_instance() && bluetoothinfo_ != nullptr;
}
inline bool EngineOnOff::has_bluetoothinfo() const {
  return _internal_has_bluetoothinfo();
}
inline void EngineOnOff::clear_bluetoothinfo() {
  if (GetArenaForAllocation() == nullptr && bluetoothinfo_ != nullptr) {
    delete bluetoothinfo_;
  }
  bluetoothinfo_ = nullptr;
}
inline const ::EventNS::BluetoothInfo& EngineOnOff::_internal_bluetoothinfo() const {
  const ::EventNS::BluetoothInfo* p = bluetoothinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventNS::BluetoothInfo&>(
      ::EventNS::_BluetoothInfo_default_instance_);
}
inline const ::EventNS::BluetoothInfo& EngineOnOff::bluetoothinfo() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.bluetoothInfo)
  return _internal_bluetoothinfo();
}
inline void EngineOnOff::unsafe_arena_set_allocated_bluetoothinfo(
    ::EventNS::BluetoothInfo* bluetoothinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bluetoothinfo_);
  }
  bluetoothinfo_ = bluetoothinfo;
  if (bluetoothinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventNS.EngineOnOff.bluetoothInfo)
}
inline ::EventNS::BluetoothInfo* EngineOnOff::release_bluetoothinfo() {
  
  ::EventNS::BluetoothInfo* temp = bluetoothinfo_;
  bluetoothinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventNS::BluetoothInfo* EngineOnOff::unsafe_arena_release_bluetoothinfo() {
  // @@protoc_insertion_point(field_release:EventNS.EngineOnOff.bluetoothInfo)
  
  ::EventNS::BluetoothInfo* temp = bluetoothinfo_;
  bluetoothinfo_ = nullptr;
  return temp;
}
inline ::EventNS::BluetoothInfo* EngineOnOff::_internal_mutable_bluetoothinfo() {
  
  if (bluetoothinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventNS::BluetoothInfo>(GetArenaForAllocation());
    bluetoothinfo_ = p;
  }
  return bluetoothinfo_;
}
inline ::EventNS::BluetoothInfo* EngineOnOff::mutable_bluetoothinfo() {
  ::EventNS::BluetoothInfo* _msg = _internal_mutable_bluetoothinfo();
  // @@protoc_insertion_point(field_mutable:EventNS.EngineOnOff.bluetoothInfo)
  return _msg;
}
inline void EngineOnOff::set_allocated_bluetoothinfo(::EventNS::BluetoothInfo* bluetoothinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bluetoothinfo_;
  }
  if (bluetoothinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::EventNS::BluetoothInfo>::GetOwningArena(bluetoothinfo);
    if (message_arena != submessage_arena) {
      bluetoothinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bluetoothinfo, submessage_arena);
    }
    
  } else {
    
  }
  bluetoothinfo_ = bluetoothinfo;
  // @@protoc_insertion_point(field_set_allocated:EventNS.EngineOnOff.bluetoothInfo)
}

// uint32 power = 5;
inline void EngineOnOff::clear_power() {
  power_ = 0u;
}
inline uint32_t EngineOnOff::_internal_power() const {
  return power_;
}
inline uint32_t EngineOnOff::power() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.power)
  return _internal_power();
}
inline void EngineOnOff::_internal_set_power(uint32_t value) {
  
  power_ = value;
}
inline void EngineOnOff::set_power(uint32_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:EventNS.EngineOnOff.power)
}

// string taskID = 6;
inline void EngineOnOff::clear_taskid() {
  taskid_.ClearToEmpty();
}
inline const std::string& EngineOnOff::taskid() const {
  // @@protoc_insertion_point(field_get:EventNS.EngineOnOff.taskID)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EngineOnOff::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.EngineOnOff.taskID)
}
inline std::string* EngineOnOff::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:EventNS.EngineOnOff.taskID)
  return _s;
}
inline const std::string& EngineOnOff::_internal_taskid() const {
  return taskid_.Get();
}
inline void EngineOnOff::_internal_set_taskid(const std::string& value) {
  
  taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EngineOnOff::_internal_mutable_taskid() {
  
  return taskid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EngineOnOff::release_taskid() {
  // @@protoc_insertion_point(field_release:EventNS.EngineOnOff.taskID)
  return taskid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EngineOnOff::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  taskid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), taskid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (taskid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    taskid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.EngineOnOff.taskID)
}

// -------------------------------------------------------------------

// BluetoothInfo

// string bluetoothName = 1;
inline void BluetoothInfo::clear_bluetoothname() {
  bluetoothname_.ClearToEmpty();
}
inline const std::string& BluetoothInfo::bluetoothname() const {
  // @@protoc_insertion_point(field_get:EventNS.BluetoothInfo.bluetoothName)
  return _internal_bluetoothname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothInfo::set_bluetoothname(ArgT0&& arg0, ArgT... args) {
 
 bluetoothname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.BluetoothInfo.bluetoothName)
}
inline std::string* BluetoothInfo::mutable_bluetoothname() {
  std::string* _s = _internal_mutable_bluetoothname();
  // @@protoc_insertion_point(field_mutable:EventNS.BluetoothInfo.bluetoothName)
  return _s;
}
inline const std::string& BluetoothInfo::_internal_bluetoothname() const {
  return bluetoothname_.Get();
}
inline void BluetoothInfo::_internal_set_bluetoothname(const std::string& value) {
  
  bluetoothname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::_internal_mutable_bluetoothname() {
  
  return bluetoothname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::release_bluetoothname() {
  // @@protoc_insertion_point(field_release:EventNS.BluetoothInfo.bluetoothName)
  return bluetoothname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BluetoothInfo::set_allocated_bluetoothname(std::string* bluetoothname) {
  if (bluetoothname != nullptr) {
    
  } else {
    
  }
  bluetoothname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bluetoothname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bluetoothname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bluetoothname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.BluetoothInfo.bluetoothName)
}

// string bluetoothPwd = 2;
inline void BluetoothInfo::clear_bluetoothpwd() {
  bluetoothpwd_.ClearToEmpty();
}
inline const std::string& BluetoothInfo::bluetoothpwd() const {
  // @@protoc_insertion_point(field_get:EventNS.BluetoothInfo.bluetoothPwd)
  return _internal_bluetoothpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothInfo::set_bluetoothpwd(ArgT0&& arg0, ArgT... args) {
 
 bluetoothpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.BluetoothInfo.bluetoothPwd)
}
inline std::string* BluetoothInfo::mutable_bluetoothpwd() {
  std::string* _s = _internal_mutable_bluetoothpwd();
  // @@protoc_insertion_point(field_mutable:EventNS.BluetoothInfo.bluetoothPwd)
  return _s;
}
inline const std::string& BluetoothInfo::_internal_bluetoothpwd() const {
  return bluetoothpwd_.Get();
}
inline void BluetoothInfo::_internal_set_bluetoothpwd(const std::string& value) {
  
  bluetoothpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::_internal_mutable_bluetoothpwd() {
  
  return bluetoothpwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::release_bluetoothpwd() {
  // @@protoc_insertion_point(field_release:EventNS.BluetoothInfo.bluetoothPwd)
  return bluetoothpwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BluetoothInfo::set_allocated_bluetoothpwd(std::string* bluetoothpwd) {
  if (bluetoothpwd != nullptr) {
    
  } else {
    
  }
  bluetoothpwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bluetoothpwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bluetoothpwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bluetoothpwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.BluetoothInfo.bluetoothPwd)
}

// string bluetoothSecretKey = 3;
inline void BluetoothInfo::clear_bluetoothsecretkey() {
  bluetoothsecretkey_.ClearToEmpty();
}
inline const std::string& BluetoothInfo::bluetoothsecretkey() const {
  // @@protoc_insertion_point(field_get:EventNS.BluetoothInfo.bluetoothSecretKey)
  return _internal_bluetoothsecretkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothInfo::set_bluetoothsecretkey(ArgT0&& arg0, ArgT... args) {
 
 bluetoothsecretkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.BluetoothInfo.bluetoothSecretKey)
}
inline std::string* BluetoothInfo::mutable_bluetoothsecretkey() {
  std::string* _s = _internal_mutable_bluetoothsecretkey();
  // @@protoc_insertion_point(field_mutable:EventNS.BluetoothInfo.bluetoothSecretKey)
  return _s;
}
inline const std::string& BluetoothInfo::_internal_bluetoothsecretkey() const {
  return bluetoothsecretkey_.Get();
}
inline void BluetoothInfo::_internal_set_bluetoothsecretkey(const std::string& value) {
  
  bluetoothsecretkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::_internal_mutable_bluetoothsecretkey() {
  
  return bluetoothsecretkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::release_bluetoothsecretkey() {
  // @@protoc_insertion_point(field_release:EventNS.BluetoothInfo.bluetoothSecretKey)
  return bluetoothsecretkey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BluetoothInfo::set_allocated_bluetoothsecretkey(std::string* bluetoothsecretkey) {
  if (bluetoothsecretkey != nullptr) {
    
  } else {
    
  }
  bluetoothsecretkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bluetoothsecretkey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bluetoothsecretkey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bluetoothsecretkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.BluetoothInfo.bluetoothSecretKey)
}

// string bluetoothMac = 4;
inline void BluetoothInfo::clear_bluetoothmac() {
  bluetoothmac_.ClearToEmpty();
}
inline const std::string& BluetoothInfo::bluetoothmac() const {
  // @@protoc_insertion_point(field_get:EventNS.BluetoothInfo.bluetoothMac)
  return _internal_bluetoothmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothInfo::set_bluetoothmac(ArgT0&& arg0, ArgT... args) {
 
 bluetoothmac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.BluetoothInfo.bluetoothMac)
}
inline std::string* BluetoothInfo::mutable_bluetoothmac() {
  std::string* _s = _internal_mutable_bluetoothmac();
  // @@protoc_insertion_point(field_mutable:EventNS.BluetoothInfo.bluetoothMac)
  return _s;
}
inline const std::string& BluetoothInfo::_internal_bluetoothmac() const {
  return bluetoothmac_.Get();
}
inline void BluetoothInfo::_internal_set_bluetoothmac(const std::string& value) {
  
  bluetoothmac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::_internal_mutable_bluetoothmac() {
  
  return bluetoothmac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BluetoothInfo::release_bluetoothmac() {
  // @@protoc_insertion_point(field_release:EventNS.BluetoothInfo.bluetoothMac)
  return bluetoothmac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BluetoothInfo::set_allocated_bluetoothmac(std::string* bluetoothmac) {
  if (bluetoothmac != nullptr) {
    
  } else {
    
  }
  bluetoothmac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bluetoothmac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bluetoothmac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bluetoothmac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.BluetoothInfo.bluetoothMac)
}

// -------------------------------------------------------------------

// BatteryInfo

// bool charging = 1;
inline void BatteryInfo::clear_charging() {
  charging_ = false;
}
inline bool BatteryInfo::_internal_charging() const {
  return charging_;
}
inline bool BatteryInfo::charging() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.charging)
  return _internal_charging();
}
inline void BatteryInfo::_internal_set_charging(bool value) {
  
  charging_ = value;
}
inline void BatteryInfo::set_charging(bool value) {
  _internal_set_charging(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.charging)
}

// uint32 quantity = 2;
inline void BatteryInfo::clear_quantity() {
  quantity_ = 0u;
}
inline uint32_t BatteryInfo::_internal_quantity() const {
  return quantity_;
}
inline uint32_t BatteryInfo::quantity() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.quantity)
  return _internal_quantity();
}
inline void BatteryInfo::_internal_set_quantity(uint32_t value) {
  
  quantity_ = value;
}
inline void BatteryInfo::set_quantity(uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.quantity)
}

// uint32 range = 3;
inline void BatteryInfo::clear_range() {
  range_ = 0u;
}
inline uint32_t BatteryInfo::_internal_range() const {
  return range_;
}
inline uint32_t BatteryInfo::range() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.range)
  return _internal_range();
}
inline void BatteryInfo::_internal_set_range(uint32_t value) {
  
  range_ = value;
}
inline void BatteryInfo::set_range(uint32_t value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.range)
}

// uint32 temp = 4;
inline void BatteryInfo::clear_temp() {
  temp_ = 0u;
}
inline uint32_t BatteryInfo::_internal_temp() const {
  return temp_;
}
inline uint32_t BatteryInfo::temp() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.temp)
  return _internal_temp();
}
inline void BatteryInfo::_internal_set_temp(uint32_t value) {
  
  temp_ = value;
}
inline void BatteryInfo::set_temp(uint32_t value) {
  _internal_set_temp(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.temp)
}

// uint32 cycle = 5;
inline void BatteryInfo::clear_cycle() {
  cycle_ = 0u;
}
inline uint32_t BatteryInfo::_internal_cycle() const {
  return cycle_;
}
inline uint32_t BatteryInfo::cycle() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.cycle)
  return _internal_cycle();
}
inline void BatteryInfo::_internal_set_cycle(uint32_t value) {
  
  cycle_ = value;
}
inline void BatteryInfo::set_cycle(uint32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.cycle)
}

// uint32 remaining = 6;
inline void BatteryInfo::clear_remaining() {
  remaining_ = 0u;
}
inline uint32_t BatteryInfo::_internal_remaining() const {
  return remaining_;
}
inline uint32_t BatteryInfo::remaining() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.remaining)
  return _internal_remaining();
}
inline void BatteryInfo::_internal_set_remaining(uint32_t value) {
  
  remaining_ = value;
}
inline void BatteryInfo::set_remaining(uint32_t value) {
  _internal_set_remaining(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.remaining)
}

// uint32 bmsId = 7;
inline void BatteryInfo::clear_bmsid() {
  bmsid_ = 0u;
}
inline uint32_t BatteryInfo::_internal_bmsid() const {
  return bmsid_;
}
inline uint32_t BatteryInfo::bmsid() const {
  // @@protoc_insertion_point(field_get:EventNS.BatteryInfo.bmsId)
  return _internal_bmsid();
}
inline void BatteryInfo::_internal_set_bmsid(uint32_t value) {
  
  bmsid_ = value;
}
inline void BatteryInfo::set_bmsid(uint32_t value) {
  _internal_set_bmsid(value);
  // @@protoc_insertion_point(field_set:EventNS.BatteryInfo.bmsId)
}

// -------------------------------------------------------------------

// SKFaultInfo

// bytes mcuFault = 1;
inline void SKFaultInfo::clear_mcufault() {
  mcufault_.ClearToEmpty();
}
inline const std::string& SKFaultInfo::mcufault() const {
  // @@protoc_insertion_point(field_get:EventNS.SKFaultInfo.mcuFault)
  return _internal_mcufault();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SKFaultInfo::set_mcufault(ArgT0&& arg0, ArgT... args) {
 
 mcufault_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.SKFaultInfo.mcuFault)
}
inline std::string* SKFaultInfo::mutable_mcufault() {
  std::string* _s = _internal_mutable_mcufault();
  // @@protoc_insertion_point(field_mutable:EventNS.SKFaultInfo.mcuFault)
  return _s;
}
inline const std::string& SKFaultInfo::_internal_mcufault() const {
  return mcufault_.Get();
}
inline void SKFaultInfo::_internal_set_mcufault(const std::string& value) {
  
  mcufault_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SKFaultInfo::_internal_mutable_mcufault() {
  
  return mcufault_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SKFaultInfo::release_mcufault() {
  // @@protoc_insertion_point(field_release:EventNS.SKFaultInfo.mcuFault)
  return mcufault_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SKFaultInfo::set_allocated_mcufault(std::string* mcufault) {
  if (mcufault != nullptr) {
    
  } else {
    
  }
  mcufault_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcufault,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mcufault_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mcufault_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.SKFaultInfo.mcuFault)
}

// bytes bmsFault = 2;
inline void SKFaultInfo::clear_bmsfault() {
  bmsfault_.ClearToEmpty();
}
inline const std::string& SKFaultInfo::bmsfault() const {
  // @@protoc_insertion_point(field_get:EventNS.SKFaultInfo.bmsFault)
  return _internal_bmsfault();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SKFaultInfo::set_bmsfault(ArgT0&& arg0, ArgT... args) {
 
 bmsfault_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.SKFaultInfo.bmsFault)
}
inline std::string* SKFaultInfo::mutable_bmsfault() {
  std::string* _s = _internal_mutable_bmsfault();
  // @@protoc_insertion_point(field_mutable:EventNS.SKFaultInfo.bmsFault)
  return _s;
}
inline const std::string& SKFaultInfo::_internal_bmsfault() const {
  return bmsfault_.Get();
}
inline void SKFaultInfo::_internal_set_bmsfault(const std::string& value) {
  
  bmsfault_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SKFaultInfo::_internal_mutable_bmsfault() {
  
  return bmsfault_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SKFaultInfo::release_bmsfault() {
  // @@protoc_insertion_point(field_release:EventNS.SKFaultInfo.bmsFault)
  return bmsfault_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SKFaultInfo::set_allocated_bmsfault(std::string* bmsfault) {
  if (bmsfault != nullptr) {
    
  } else {
    
  }
  bmsfault_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bmsfault,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bmsfault_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bmsfault_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.SKFaultInfo.bmsFault)
}

// -------------------------------------------------------------------

// SideStandInfo

// .EventNS.SideStandStatus status = 1;
inline void SideStandInfo::clear_status() {
  status_ = 0;
}
inline ::EventNS::SideStandStatus SideStandInfo::_internal_status() const {
  return static_cast< ::EventNS::SideStandStatus >(status_);
}
inline ::EventNS::SideStandStatus SideStandInfo::status() const {
  // @@protoc_insertion_point(field_get:EventNS.SideStandInfo.status)
  return _internal_status();
}
inline void SideStandInfo::_internal_set_status(::EventNS::SideStandStatus value) {
  
  status_ = value;
}
inline void SideStandInfo::set_status(::EventNS::SideStandStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:EventNS.SideStandInfo.status)
}

// -------------------------------------------------------------------

// LampInfo

// .EventNS.LampType lampType = 1;
inline void LampInfo::clear_lamptype() {
  lamptype_ = 0;
}
inline ::EventNS::LampType LampInfo::_internal_lamptype() const {
  return static_cast< ::EventNS::LampType >(lamptype_);
}
inline ::EventNS::LampType LampInfo::lamptype() const {
  // @@protoc_insertion_point(field_get:EventNS.LampInfo.lampType)
  return _internal_lamptype();
}
inline void LampInfo::_internal_set_lamptype(::EventNS::LampType value) {
  
  lamptype_ = value;
}
inline void LampInfo::set_lamptype(::EventNS::LampType value) {
  _internal_set_lamptype(value);
  // @@protoc_insertion_point(field_set:EventNS.LampInfo.lampType)
}

// .EventNS.LampStatus lampStatus = 2;
inline void LampInfo::clear_lampstatus() {
  lampstatus_ = 0;
}
inline ::EventNS::LampStatus LampInfo::_internal_lampstatus() const {
  return static_cast< ::EventNS::LampStatus >(lampstatus_);
}
inline ::EventNS::LampStatus LampInfo::lampstatus() const {
  // @@protoc_insertion_point(field_get:EventNS.LampInfo.lampStatus)
  return _internal_lampstatus();
}
inline void LampInfo::_internal_set_lampstatus(::EventNS::LampStatus value) {
  
  lampstatus_ = value;
}
inline void LampInfo::set_lampstatus(::EventNS::LampStatus value) {
  _internal_set_lampstatus(value);
  // @@protoc_insertion_point(field_set:EventNS.LampInfo.lampStatus)
}

// -------------------------------------------------------------------

// SeatBucketOpenClose

// .EventNS.SeatBucketStatus status = 1;
inline void SeatBucketOpenClose::clear_status() {
  status_ = 0;
}
inline ::EventNS::SeatBucketStatus SeatBucketOpenClose::_internal_status() const {
  return static_cast< ::EventNS::SeatBucketStatus >(status_);
}
inline ::EventNS::SeatBucketStatus SeatBucketOpenClose::status() const {
  // @@protoc_insertion_point(field_get:EventNS.SeatBucketOpenClose.status)
  return _internal_status();
}
inline void SeatBucketOpenClose::_internal_set_status(::EventNS::SeatBucketStatus value) {
  
  status_ = value;
}
inline void SeatBucketOpenClose::set_status(::EventNS::SeatBucketStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:EventNS.SeatBucketOpenClose.status)
}

// -------------------------------------------------------------------

// EventAck

// uint32 result = 1;
inline void EventAck::clear_result() {
  result_ = 0u;
}
inline uint32_t EventAck::_internal_result() const {
  return result_;
}
inline uint32_t EventAck::result() const {
  // @@protoc_insertion_point(field_get:EventNS.EventAck.result)
  return _internal_result();
}
inline void EventAck::_internal_set_result(uint32_t value) {
  
  result_ = value;
}
inline void EventAck::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:EventNS.EventAck.result)
}

// string taskID = 2;
inline void EventAck::clear_taskid() {
  taskid_.ClearToEmpty();
}
inline const std::string& EventAck::taskid() const {
  // @@protoc_insertion_point(field_get:EventNS.EventAck.taskID)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventAck::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventNS.EventAck.taskID)
}
inline std::string* EventAck::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:EventNS.EventAck.taskID)
  return _s;
}
inline const std::string& EventAck::_internal_taskid() const {
  return taskid_.Get();
}
inline void EventAck::_internal_set_taskid(const std::string& value) {
  
  taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventAck::_internal_mutable_taskid() {
  
  return taskid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventAck::release_taskid() {
  // @@protoc_insertion_point(field_release:EventNS.EventAck.taskID)
  return taskid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventAck::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  taskid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), taskid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (taskid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    taskid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventNS.EventAck.taskID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace EventNS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EventNS::SideStandStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EventNS::SideStandStatus>() {
  return ::EventNS::SideStandStatus_descriptor();
}
template <> struct is_proto_enum< ::EventNS::LampType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EventNS::LampType>() {
  return ::EventNS::LampType_descriptor();
}
template <> struct is_proto_enum< ::EventNS::LampStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EventNS::LampStatus>() {
  return ::EventNS::LampStatus_descriptor();
}
template <> struct is_proto_enum< ::EventNS::SeatBucketStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EventNS::SeatBucketStatus>() {
  return ::EventNS::SeatBucketStatus_descriptor();
}
template <> struct is_proto_enum< ::EventNS::EventItem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EventNS::EventItem>() {
  return ::EventNS::EventItem_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_event_2eproto
