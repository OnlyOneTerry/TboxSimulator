// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_status_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_status_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_status_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_status_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_status_2eproto;
namespace StatusNS {
class BmsInfo;
struct BmsInfoDefaultTypeInternal;
extern BmsInfoDefaultTypeInternal _BmsInfo_default_instance_;
class BmsSKInfo;
struct BmsSKInfoDefaultTypeInternal;
extern BmsSKInfoDefaultTypeInternal _BmsSKInfo_default_instance_;
class CanInfo;
struct CanInfoDefaultTypeInternal;
extern CanInfoDefaultTypeInternal _CanInfo_default_instance_;
class HmiInfo;
struct HmiInfoDefaultTypeInternal;
extern HmiInfoDefaultTypeInternal _HmiInfo_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TboxInfo;
struct TboxInfoDefaultTypeInternal;
extern TboxInfoDefaultTypeInternal _TboxInfo_default_instance_;
class TboxSKInfo;
struct TboxSKInfoDefaultTypeInternal;
extern TboxSKInfoDefaultTypeInternal _TboxSKInfo_default_instance_;
class TpmsInfo;
struct TpmsInfoDefaultTypeInternal;
extern TpmsInfoDefaultTypeInternal _TpmsInfo_default_instance_;
}  // namespace StatusNS
PROTOBUF_NAMESPACE_OPEN
template<> ::StatusNS::BmsInfo* Arena::CreateMaybeMessage<::StatusNS::BmsInfo>(Arena*);
template<> ::StatusNS::BmsSKInfo* Arena::CreateMaybeMessage<::StatusNS::BmsSKInfo>(Arena*);
template<> ::StatusNS::CanInfo* Arena::CreateMaybeMessage<::StatusNS::CanInfo>(Arena*);
template<> ::StatusNS::HmiInfo* Arena::CreateMaybeMessage<::StatusNS::HmiInfo>(Arena*);
template<> ::StatusNS::Status* Arena::CreateMaybeMessage<::StatusNS::Status>(Arena*);
template<> ::StatusNS::TboxInfo* Arena::CreateMaybeMessage<::StatusNS::TboxInfo>(Arena*);
template<> ::StatusNS::TboxSKInfo* Arena::CreateMaybeMessage<::StatusNS::TboxSKInfo>(Arena*);
template<> ::StatusNS::TpmsInfo* Arena::CreateMaybeMessage<::StatusNS::TpmsInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace StatusNS {

enum GearPosition : int {
  INVALID = 0,
  GEAR_0 = 1,
  GEAR_1 = 2,
  GEAR_2 = 3,
  GEAR_3 = 4,
  GEAR_P = 5,
  GEAR_R = 6,
  GEAR_D = 7,
  GEAR_F = 8,
  GEAR_N = 9,
  GEAR_4 = 10,
  GearPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GearPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GearPosition_IsValid(int value);
constexpr GearPosition GearPosition_MIN = INVALID;
constexpr GearPosition GearPosition_MAX = GEAR_4;
constexpr int GearPosition_ARRAYSIZE = GearPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GearPosition_descriptor();
template<typename T>
inline const std::string& GearPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GearPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GearPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GearPosition_descriptor(), enum_t_value);
}
inline bool GearPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GearPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GearPosition>(
    GearPosition_descriptor(), name, value);
}
// ===================================================================

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit constexpr Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBmsSKInfoFieldNumber = 3,
    kHmiInfoFieldNumber = 1,
    kTboxSKInfoFieldNumber = 2,
    kTboxInfoFieldNumber = 4,
    kBmsInfoFieldNumber = 5,
    kTpmsInfoFieldNumber = 6,
  };
  // repeated .StatusNS.BmsSKInfo bmsSKInfo = 3;
  int bmsskinfo_size() const;
  private:
  int _internal_bmsskinfo_size() const;
  public:
  void clear_bmsskinfo();
  ::StatusNS::BmsSKInfo* mutable_bmsskinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::BmsSKInfo >*
      mutable_bmsskinfo();
  private:
  const ::StatusNS::BmsSKInfo& _internal_bmsskinfo(int index) const;
  ::StatusNS::BmsSKInfo* _internal_add_bmsskinfo();
  public:
  const ::StatusNS::BmsSKInfo& bmsskinfo(int index) const;
  ::StatusNS::BmsSKInfo* add_bmsskinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::BmsSKInfo >&
      bmsskinfo() const;

  // .StatusNS.HmiInfo hmiInfo = 1;
  bool has_hmiinfo() const;
  private:
  bool _internal_has_hmiinfo() const;
  public:
  void clear_hmiinfo();
  const ::StatusNS::HmiInfo& hmiinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::HmiInfo* release_hmiinfo();
  ::StatusNS::HmiInfo* mutable_hmiinfo();
  void set_allocated_hmiinfo(::StatusNS::HmiInfo* hmiinfo);
  private:
  const ::StatusNS::HmiInfo& _internal_hmiinfo() const;
  ::StatusNS::HmiInfo* _internal_mutable_hmiinfo();
  public:
  void unsafe_arena_set_allocated_hmiinfo(
      ::StatusNS::HmiInfo* hmiinfo);
  ::StatusNS::HmiInfo* unsafe_arena_release_hmiinfo();

  // .StatusNS.TboxSKInfo tboxSKInfo = 2;
  bool has_tboxskinfo() const;
  private:
  bool _internal_has_tboxskinfo() const;
  public:
  void clear_tboxskinfo();
  const ::StatusNS::TboxSKInfo& tboxskinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::TboxSKInfo* release_tboxskinfo();
  ::StatusNS::TboxSKInfo* mutable_tboxskinfo();
  void set_allocated_tboxskinfo(::StatusNS::TboxSKInfo* tboxskinfo);
  private:
  const ::StatusNS::TboxSKInfo& _internal_tboxskinfo() const;
  ::StatusNS::TboxSKInfo* _internal_mutable_tboxskinfo();
  public:
  void unsafe_arena_set_allocated_tboxskinfo(
      ::StatusNS::TboxSKInfo* tboxskinfo);
  ::StatusNS::TboxSKInfo* unsafe_arena_release_tboxskinfo();

  // .StatusNS.TboxInfo tboxInfo = 4;
  bool has_tboxinfo() const;
  private:
  bool _internal_has_tboxinfo() const;
  public:
  void clear_tboxinfo();
  const ::StatusNS::TboxInfo& tboxinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::TboxInfo* release_tboxinfo();
  ::StatusNS::TboxInfo* mutable_tboxinfo();
  void set_allocated_tboxinfo(::StatusNS::TboxInfo* tboxinfo);
  private:
  const ::StatusNS::TboxInfo& _internal_tboxinfo() const;
  ::StatusNS::TboxInfo* _internal_mutable_tboxinfo();
  public:
  void unsafe_arena_set_allocated_tboxinfo(
      ::StatusNS::TboxInfo* tboxinfo);
  ::StatusNS::TboxInfo* unsafe_arena_release_tboxinfo();

  // .StatusNS.BmsInfo bmsInfo = 5;
  bool has_bmsinfo() const;
  private:
  bool _internal_has_bmsinfo() const;
  public:
  void clear_bmsinfo();
  const ::StatusNS::BmsInfo& bmsinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::BmsInfo* release_bmsinfo();
  ::StatusNS::BmsInfo* mutable_bmsinfo();
  void set_allocated_bmsinfo(::StatusNS::BmsInfo* bmsinfo);
  private:
  const ::StatusNS::BmsInfo& _internal_bmsinfo() const;
  ::StatusNS::BmsInfo* _internal_mutable_bmsinfo();
  public:
  void unsafe_arena_set_allocated_bmsinfo(
      ::StatusNS::BmsInfo* bmsinfo);
  ::StatusNS::BmsInfo* unsafe_arena_release_bmsinfo();

  // .StatusNS.TpmsInfo tpmsInfo = 6;
  bool has_tpmsinfo() const;
  private:
  bool _internal_has_tpmsinfo() const;
  public:
  void clear_tpmsinfo();
  const ::StatusNS::TpmsInfo& tpmsinfo() const;
  PROTOBUF_NODISCARD ::StatusNS::TpmsInfo* release_tpmsinfo();
  ::StatusNS::TpmsInfo* mutable_tpmsinfo();
  void set_allocated_tpmsinfo(::StatusNS::TpmsInfo* tpmsinfo);
  private:
  const ::StatusNS::TpmsInfo& _internal_tpmsinfo() const;
  ::StatusNS::TpmsInfo* _internal_mutable_tpmsinfo();
  public:
  void unsafe_arena_set_allocated_tpmsinfo(
      ::StatusNS::TpmsInfo* tpmsinfo);
  ::StatusNS::TpmsInfo* unsafe_arena_release_tpmsinfo();

  // @@protoc_insertion_point(class_scope:StatusNS.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::BmsSKInfo > bmsskinfo_;
  ::StatusNS::HmiInfo* hmiinfo_;
  ::StatusNS::TboxSKInfo* tboxskinfo_;
  ::StatusNS::TboxInfo* tboxinfo_;
  ::StatusNS::BmsInfo* bmsinfo_;
  ::StatusNS::TpmsInfo* tpmsinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class HmiInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.HmiInfo) */ {
 public:
  inline HmiInfo() : HmiInfo(nullptr) {}
  ~HmiInfo() override;
  explicit constexpr HmiInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HmiInfo(const HmiInfo& from);
  HmiInfo(HmiInfo&& from) noexcept
    : HmiInfo() {
    *this = ::std::move(from);
  }

  inline HmiInfo& operator=(const HmiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HmiInfo& operator=(HmiInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HmiInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HmiInfo* internal_default_instance() {
    return reinterpret_cast<const HmiInfo*>(
               &_HmiInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HmiInfo& a, HmiInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HmiInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HmiInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HmiInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HmiInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HmiInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HmiInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HmiInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.HmiInfo";
  }
  protected:
  explicit HmiInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOdoMetroFieldNumber = 1,
    kEnduranceMileageFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kRevSpeedFieldNumber = 4,
    kGearPositionFieldNumber = 5,
  };
  // uint32 odoMetro = 1;
  void clear_odometro();
  uint32_t odometro() const;
  void set_odometro(uint32_t value);
  private:
  uint32_t _internal_odometro() const;
  void _internal_set_odometro(uint32_t value);
  public:

  // uint32 enduranceMileage = 2;
  void clear_endurancemileage();
  uint32_t endurancemileage() const;
  void set_endurancemileage(uint32_t value);
  private:
  uint32_t _internal_endurancemileage() const;
  void _internal_set_endurancemileage(uint32_t value);
  public:

  // uint32 speed = 3;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 revSpeed = 4;
  void clear_revspeed();
  uint32_t revspeed() const;
  void set_revspeed(uint32_t value);
  private:
  uint32_t _internal_revspeed() const;
  void _internal_set_revspeed(uint32_t value);
  public:

  // .StatusNS.GearPosition gearPosition = 5;
  void clear_gearposition();
  ::StatusNS::GearPosition gearposition() const;
  void set_gearposition(::StatusNS::GearPosition value);
  private:
  ::StatusNS::GearPosition _internal_gearposition() const;
  void _internal_set_gearposition(::StatusNS::GearPosition value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.HmiInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t odometro_;
  uint32_t endurancemileage_;
  uint32_t speed_;
  uint32_t revspeed_;
  int gearposition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class BmsSKInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.BmsSKInfo) */ {
 public:
  inline BmsSKInfo() : BmsSKInfo(nullptr) {}
  ~BmsSKInfo() override;
  explicit constexpr BmsSKInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BmsSKInfo(const BmsSKInfo& from);
  BmsSKInfo(BmsSKInfo&& from) noexcept
    : BmsSKInfo() {
    *this = ::std::move(from);
  }

  inline BmsSKInfo& operator=(const BmsSKInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BmsSKInfo& operator=(BmsSKInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BmsSKInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BmsSKInfo* internal_default_instance() {
    return reinterpret_cast<const BmsSKInfo*>(
               &_BmsSKInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BmsSKInfo& a, BmsSKInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BmsSKInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BmsSKInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BmsSKInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BmsSKInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BmsSKInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BmsSKInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BmsSKInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.BmsSKInfo";
  }
  protected:
  explicit BmsSKInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBmsVoltageFieldNumber = 1,
    kBmsElectricFieldNumber = 2,
    kBmsSOCFieldNumber = 3,
    kBmsTempFieldNumber = 4,
  };
  // uint32 bmsVoltage = 1;
  void clear_bmsvoltage();
  uint32_t bmsvoltage() const;
  void set_bmsvoltage(uint32_t value);
  private:
  uint32_t _internal_bmsvoltage() const;
  void _internal_set_bmsvoltage(uint32_t value);
  public:

  // uint32 bmsElectric = 2;
  void clear_bmselectric();
  uint32_t bmselectric() const;
  void set_bmselectric(uint32_t value);
  private:
  uint32_t _internal_bmselectric() const;
  void _internal_set_bmselectric(uint32_t value);
  public:

  // uint32 bmsSOC = 3;
  void clear_bmssoc();
  uint32_t bmssoc() const;
  void set_bmssoc(uint32_t value);
  private:
  uint32_t _internal_bmssoc() const;
  void _internal_set_bmssoc(uint32_t value);
  public:

  // uint32 bmsTemp = 4;
  void clear_bmstemp();
  uint32_t bmstemp() const;
  void set_bmstemp(uint32_t value);
  private:
  uint32_t _internal_bmstemp() const;
  void _internal_set_bmstemp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.BmsSKInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t bmsvoltage_;
  uint32_t bmselectric_;
  uint32_t bmssoc_;
  uint32_t bmstemp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class BmsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.BmsInfo) */ {
 public:
  inline BmsInfo() : BmsInfo(nullptr) {}
  ~BmsInfo() override;
  explicit constexpr BmsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BmsInfo(const BmsInfo& from);
  BmsInfo(BmsInfo&& from) noexcept
    : BmsInfo() {
    *this = ::std::move(from);
  }

  inline BmsInfo& operator=(const BmsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BmsInfo& operator=(BmsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BmsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BmsInfo* internal_default_instance() {
    return reinterpret_cast<const BmsInfo*>(
               &_BmsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BmsInfo& a, BmsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BmsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BmsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BmsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BmsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BmsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BmsInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BmsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.BmsInfo";
  }
  protected:
  explicit BmsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBmsVoltageFieldNumber = 1,
    kBmsElectricFieldNumber = 2,
    kBmsSOCFieldNumber = 3,
    kBmsTempFieldNumber = 4,
  };
  // uint32 bmsVoltage = 1;
  void clear_bmsvoltage();
  uint32_t bmsvoltage() const;
  void set_bmsvoltage(uint32_t value);
  private:
  uint32_t _internal_bmsvoltage() const;
  void _internal_set_bmsvoltage(uint32_t value);
  public:

  // uint32 bmsElectric = 2;
  void clear_bmselectric();
  uint32_t bmselectric() const;
  void set_bmselectric(uint32_t value);
  private:
  uint32_t _internal_bmselectric() const;
  void _internal_set_bmselectric(uint32_t value);
  public:

  // uint32 bmsSOC = 3;
  void clear_bmssoc();
  uint32_t bmssoc() const;
  void set_bmssoc(uint32_t value);
  private:
  uint32_t _internal_bmssoc() const;
  void _internal_set_bmssoc(uint32_t value);
  public:

  // uint32 bmsTemp = 4;
  void clear_bmstemp();
  uint32_t bmstemp() const;
  void set_bmstemp(uint32_t value);
  private:
  uint32_t _internal_bmstemp() const;
  void _internal_set_bmstemp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.BmsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t bmsvoltage_;
  uint32_t bmselectric_;
  uint32_t bmssoc_;
  uint32_t bmstemp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class TboxSKInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.TboxSKInfo) */ {
 public:
  inline TboxSKInfo() : TboxSKInfo(nullptr) {}
  ~TboxSKInfo() override;
  explicit constexpr TboxSKInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TboxSKInfo(const TboxSKInfo& from);
  TboxSKInfo(TboxSKInfo&& from) noexcept
    : TboxSKInfo() {
    *this = ::std::move(from);
  }

  inline TboxSKInfo& operator=(const TboxSKInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TboxSKInfo& operator=(TboxSKInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TboxSKInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TboxSKInfo* internal_default_instance() {
    return reinterpret_cast<const TboxSKInfo*>(
               &_TboxSKInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TboxSKInfo& a, TboxSKInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TboxSKInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TboxSKInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TboxSKInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TboxSKInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TboxSKInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TboxSKInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TboxSKInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.TboxSKInfo";
  }
  protected:
  explicit TboxSKInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanInfoFieldNumber = 5,
    kLocationFieldNumber = 6,
    kKl15FieldNumber = 1,
    kKl30FieldNumber = 2,
    kBatteryVoltageFieldNumber = 3,
    kCsqFieldNumber = 4,
    kRapidAccelerationCountFieldNumber = 7,
    kRapidDecelerationCountFieldNumber = 8,
    kEmergencyBrakeCountFieldNumber = 9,
    kSharpTurnCountFieldNumber = 10,
  };
  // repeated .StatusNS.CanInfo canInfo = 5;
  int caninfo_size() const;
  private:
  int _internal_caninfo_size() const;
  public:
  void clear_caninfo();
  ::StatusNS::CanInfo* mutable_caninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >*
      mutable_caninfo();
  private:
  const ::StatusNS::CanInfo& _internal_caninfo(int index) const;
  ::StatusNS::CanInfo* _internal_add_caninfo();
  public:
  const ::StatusNS::CanInfo& caninfo(int index) const;
  ::StatusNS::CanInfo* add_caninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >&
      caninfo() const;

  // bytes location = 6;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // bool kl15 = 1;
  void clear_kl15();
  bool kl15() const;
  void set_kl15(bool value);
  private:
  bool _internal_kl15() const;
  void _internal_set_kl15(bool value);
  public:

  // uint32 kl30 = 2;
  void clear_kl30();
  uint32_t kl30() const;
  void set_kl30(uint32_t value);
  private:
  uint32_t _internal_kl30() const;
  void _internal_set_kl30(uint32_t value);
  public:

  // uint32 batteryVoltage = 3;
  void clear_batteryvoltage();
  uint32_t batteryvoltage() const;
  void set_batteryvoltage(uint32_t value);
  private:
  uint32_t _internal_batteryvoltage() const;
  void _internal_set_batteryvoltage(uint32_t value);
  public:

  // uint32 csq = 4;
  void clear_csq();
  uint32_t csq() const;
  void set_csq(uint32_t value);
  private:
  uint32_t _internal_csq() const;
  void _internal_set_csq(uint32_t value);
  public:

  // uint32 rapidAccelerationCount = 7;
  void clear_rapidaccelerationcount();
  uint32_t rapidaccelerationcount() const;
  void set_rapidaccelerationcount(uint32_t value);
  private:
  uint32_t _internal_rapidaccelerationcount() const;
  void _internal_set_rapidaccelerationcount(uint32_t value);
  public:

  // uint32 rapidDecelerationCount = 8;
  void clear_rapiddecelerationcount();
  uint32_t rapiddecelerationcount() const;
  void set_rapiddecelerationcount(uint32_t value);
  private:
  uint32_t _internal_rapiddecelerationcount() const;
  void _internal_set_rapiddecelerationcount(uint32_t value);
  public:

  // uint32 emergencyBrakeCount = 9;
  void clear_emergencybrakecount();
  uint32_t emergencybrakecount() const;
  void set_emergencybrakecount(uint32_t value);
  private:
  uint32_t _internal_emergencybrakecount() const;
  void _internal_set_emergencybrakecount(uint32_t value);
  public:

  // uint32 sharpTurnCount = 10;
  void clear_sharpturncount();
  uint32_t sharpturncount() const;
  void set_sharpturncount(uint32_t value);
  private:
  uint32_t _internal_sharpturncount() const;
  void _internal_set_sharpturncount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.TboxSKInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo > caninfo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  bool kl15_;
  uint32_t kl30_;
  uint32_t batteryvoltage_;
  uint32_t csq_;
  uint32_t rapidaccelerationcount_;
  uint32_t rapiddecelerationcount_;
  uint32_t emergencybrakecount_;
  uint32_t sharpturncount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class TboxInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.TboxInfo) */ {
 public:
  inline TboxInfo() : TboxInfo(nullptr) {}
  ~TboxInfo() override;
  explicit constexpr TboxInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TboxInfo(const TboxInfo& from);
  TboxInfo(TboxInfo&& from) noexcept
    : TboxInfo() {
    *this = ::std::move(from);
  }

  inline TboxInfo& operator=(const TboxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TboxInfo& operator=(TboxInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TboxInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TboxInfo* internal_default_instance() {
    return reinterpret_cast<const TboxInfo*>(
               &_TboxInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TboxInfo& a, TboxInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TboxInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TboxInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TboxInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TboxInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TboxInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TboxInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TboxInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.TboxInfo";
  }
  protected:
  explicit TboxInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanInfoFieldNumber = 5,
    kLocationFieldNumber = 6,
    kKl15FieldNumber = 1,
    kKl30FieldNumber = 2,
    kBatteryVoltageFieldNumber = 3,
    kCsqFieldNumber = 4,
    kRapidAccelerationCountFieldNumber = 7,
    kRapidDecelerationCountFieldNumber = 8,
    kEmergencyBrakeCountFieldNumber = 9,
    kSharpTurnCountFieldNumber = 10,
  };
  // repeated .StatusNS.CanInfo canInfo = 5;
  int caninfo_size() const;
  private:
  int _internal_caninfo_size() const;
  public:
  void clear_caninfo();
  ::StatusNS::CanInfo* mutable_caninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >*
      mutable_caninfo();
  private:
  const ::StatusNS::CanInfo& _internal_caninfo(int index) const;
  ::StatusNS::CanInfo* _internal_add_caninfo();
  public:
  const ::StatusNS::CanInfo& caninfo(int index) const;
  ::StatusNS::CanInfo* add_caninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >&
      caninfo() const;

  // bytes location = 6;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // bool kl15 = 1;
  void clear_kl15();
  bool kl15() const;
  void set_kl15(bool value);
  private:
  bool _internal_kl15() const;
  void _internal_set_kl15(bool value);
  public:

  // uint32 kl30 = 2;
  void clear_kl30();
  uint32_t kl30() const;
  void set_kl30(uint32_t value);
  private:
  uint32_t _internal_kl30() const;
  void _internal_set_kl30(uint32_t value);
  public:

  // uint32 batteryVoltage = 3;
  void clear_batteryvoltage();
  uint32_t batteryvoltage() const;
  void set_batteryvoltage(uint32_t value);
  private:
  uint32_t _internal_batteryvoltage() const;
  void _internal_set_batteryvoltage(uint32_t value);
  public:

  // uint32 csq = 4;
  void clear_csq();
  uint32_t csq() const;
  void set_csq(uint32_t value);
  private:
  uint32_t _internal_csq() const;
  void _internal_set_csq(uint32_t value);
  public:

  // uint32 rapidAccelerationCount = 7;
  void clear_rapidaccelerationcount();
  uint32_t rapidaccelerationcount() const;
  void set_rapidaccelerationcount(uint32_t value);
  private:
  uint32_t _internal_rapidaccelerationcount() const;
  void _internal_set_rapidaccelerationcount(uint32_t value);
  public:

  // uint32 rapidDecelerationCount = 8;
  void clear_rapiddecelerationcount();
  uint32_t rapiddecelerationcount() const;
  void set_rapiddecelerationcount(uint32_t value);
  private:
  uint32_t _internal_rapiddecelerationcount() const;
  void _internal_set_rapiddecelerationcount(uint32_t value);
  public:

  // uint32 emergencyBrakeCount = 9;
  void clear_emergencybrakecount();
  uint32_t emergencybrakecount() const;
  void set_emergencybrakecount(uint32_t value);
  private:
  uint32_t _internal_emergencybrakecount() const;
  void _internal_set_emergencybrakecount(uint32_t value);
  public:

  // uint32 sharpTurnCount = 10;
  void clear_sharpturncount();
  uint32_t sharpturncount() const;
  void set_sharpturncount(uint32_t value);
  private:
  uint32_t _internal_sharpturncount() const;
  void _internal_set_sharpturncount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.TboxInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo > caninfo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  bool kl15_;
  uint32_t kl30_;
  uint32_t batteryvoltage_;
  uint32_t csq_;
  uint32_t rapidaccelerationcount_;
  uint32_t rapiddecelerationcount_;
  uint32_t emergencybrakecount_;
  uint32_t sharpturncount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class TpmsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.TpmsInfo) */ {
 public:
  inline TpmsInfo() : TpmsInfo(nullptr) {}
  ~TpmsInfo() override;
  explicit constexpr TpmsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TpmsInfo(const TpmsInfo& from);
  TpmsInfo(TpmsInfo&& from) noexcept
    : TpmsInfo() {
    *this = ::std::move(from);
  }

  inline TpmsInfo& operator=(const TpmsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TpmsInfo& operator=(TpmsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TpmsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TpmsInfo* internal_default_instance() {
    return reinterpret_cast<const TpmsInfo*>(
               &_TpmsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TpmsInfo& a, TpmsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TpmsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TpmsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TpmsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TpmsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TpmsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TpmsInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TpmsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.TpmsInfo";
  }
  protected:
  explicit TpmsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrontTierTempFieldNumber = 1,
    kRearTireTempFieldNumber = 2,
    kFrontTirePressureFieldNumber = 3,
    kRearTirePressureFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // int32 frontTierTemp = 1;
  void clear_fronttiertemp();
  int32_t fronttiertemp() const;
  void set_fronttiertemp(int32_t value);
  private:
  int32_t _internal_fronttiertemp() const;
  void _internal_set_fronttiertemp(int32_t value);
  public:

  // int32 rearTireTemp = 2;
  void clear_reartiretemp();
  int32_t reartiretemp() const;
  void set_reartiretemp(int32_t value);
  private:
  int32_t _internal_reartiretemp() const;
  void _internal_set_reartiretemp(int32_t value);
  public:

  // int32 frontTirePressure = 3;
  void clear_fronttirepressure();
  int32_t fronttirepressure() const;
  void set_fronttirepressure(int32_t value);
  private:
  int32_t _internal_fronttirepressure() const;
  void _internal_set_fronttirepressure(int32_t value);
  public:

  // int32 rearTirePressure = 4;
  void clear_reartirepressure();
  int32_t reartirepressure() const;
  void set_reartirepressure(int32_t value);
  private:
  int32_t _internal_reartirepressure() const;
  void _internal_set_reartirepressure(int32_t value);
  public:

  // uint32 status = 5;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.TpmsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t fronttiertemp_;
  int32_t reartiretemp_;
  int32_t fronttirepressure_;
  int32_t reartirepressure_;
  uint32_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class CanInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusNS.CanInfo) */ {
 public:
  inline CanInfo() : CanInfo(nullptr) {}
  ~CanInfo() override;
  explicit constexpr CanInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CanInfo(const CanInfo& from);
  CanInfo(CanInfo&& from) noexcept
    : CanInfo() {
    *this = ::std::move(from);
  }

  inline CanInfo& operator=(const CanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanInfo& operator=(CanInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanInfo* internal_default_instance() {
    return reinterpret_cast<const CanInfo*>(
               &_CanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CanInfo& a, CanInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CanInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CanInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CanInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CanInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusNS.CanInfo";
  }
  protected:
  explicit CanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanChannelFieldNumber = 1,
    kBusOffFieldNumber = 2,
    kNoAckFieldNumber = 3,
    kSendNumFieldNumber = 4,
    kRecvNumFieldNumber = 5,
  };
  // uint32 canChannel = 1;
  void clear_canchannel();
  uint32_t canchannel() const;
  void set_canchannel(uint32_t value);
  private:
  uint32_t _internal_canchannel() const;
  void _internal_set_canchannel(uint32_t value);
  public:

  // bool busOff = 2;
  void clear_busoff();
  bool busoff() const;
  void set_busoff(bool value);
  private:
  bool _internal_busoff() const;
  void _internal_set_busoff(bool value);
  public:

  // bool noAck = 3;
  void clear_noack();
  bool noack() const;
  void set_noack(bool value);
  private:
  bool _internal_noack() const;
  void _internal_set_noack(bool value);
  public:

  // uint32 sendNum = 4;
  void clear_sendnum();
  uint32_t sendnum() const;
  void set_sendnum(uint32_t value);
  private:
  uint32_t _internal_sendnum() const;
  void _internal_set_sendnum(uint32_t value);
  public:

  // uint32 recvNum = 5;
  void clear_recvnum();
  uint32_t recvnum() const;
  void set_recvnum(uint32_t value);
  private:
  uint32_t _internal_recvnum() const;
  void _internal_set_recvnum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StatusNS.CanInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t canchannel_;
  bool busoff_;
  bool noack_;
  uint32_t sendnum_;
  uint32_t recvnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_status_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Status

// .StatusNS.HmiInfo hmiInfo = 1;
inline bool Status::_internal_has_hmiinfo() const {
  return this != internal_default_instance() && hmiinfo_ != nullptr;
}
inline bool Status::has_hmiinfo() const {
  return _internal_has_hmiinfo();
}
inline void Status::clear_hmiinfo() {
  if (GetArenaForAllocation() == nullptr && hmiinfo_ != nullptr) {
    delete hmiinfo_;
  }
  hmiinfo_ = nullptr;
}
inline const ::StatusNS::HmiInfo& Status::_internal_hmiinfo() const {
  const ::StatusNS::HmiInfo* p = hmiinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::HmiInfo&>(
      ::StatusNS::_HmiInfo_default_instance_);
}
inline const ::StatusNS::HmiInfo& Status::hmiinfo() const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.hmiInfo)
  return _internal_hmiinfo();
}
inline void Status::unsafe_arena_set_allocated_hmiinfo(
    ::StatusNS::HmiInfo* hmiinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hmiinfo_);
  }
  hmiinfo_ = hmiinfo;
  if (hmiinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusNS.Status.hmiInfo)
}
inline ::StatusNS::HmiInfo* Status::release_hmiinfo() {
  
  ::StatusNS::HmiInfo* temp = hmiinfo_;
  hmiinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::HmiInfo* Status::unsafe_arena_release_hmiinfo() {
  // @@protoc_insertion_point(field_release:StatusNS.Status.hmiInfo)
  
  ::StatusNS::HmiInfo* temp = hmiinfo_;
  hmiinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::HmiInfo* Status::_internal_mutable_hmiinfo() {
  
  if (hmiinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::HmiInfo>(GetArenaForAllocation());
    hmiinfo_ = p;
  }
  return hmiinfo_;
}
inline ::StatusNS::HmiInfo* Status::mutable_hmiinfo() {
  ::StatusNS::HmiInfo* _msg = _internal_mutable_hmiinfo();
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.hmiInfo)
  return _msg;
}
inline void Status::set_allocated_hmiinfo(::StatusNS::HmiInfo* hmiinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hmiinfo_;
  }
  if (hmiinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatusNS::HmiInfo>::GetOwningArena(hmiinfo);
    if (message_arena != submessage_arena) {
      hmiinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hmiinfo, submessage_arena);
    }
    
  } else {
    
  }
  hmiinfo_ = hmiinfo;
  // @@protoc_insertion_point(field_set_allocated:StatusNS.Status.hmiInfo)
}

// .StatusNS.TboxSKInfo tboxSKInfo = 2;
inline bool Status::_internal_has_tboxskinfo() const {
  return this != internal_default_instance() && tboxskinfo_ != nullptr;
}
inline bool Status::has_tboxskinfo() const {
  return _internal_has_tboxskinfo();
}
inline void Status::clear_tboxskinfo() {
  if (GetArenaForAllocation() == nullptr && tboxskinfo_ != nullptr) {
    delete tboxskinfo_;
  }
  tboxskinfo_ = nullptr;
}
inline const ::StatusNS::TboxSKInfo& Status::_internal_tboxskinfo() const {
  const ::StatusNS::TboxSKInfo* p = tboxskinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::TboxSKInfo&>(
      ::StatusNS::_TboxSKInfo_default_instance_);
}
inline const ::StatusNS::TboxSKInfo& Status::tboxskinfo() const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.tboxSKInfo)
  return _internal_tboxskinfo();
}
inline void Status::unsafe_arena_set_allocated_tboxskinfo(
    ::StatusNS::TboxSKInfo* tboxskinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tboxskinfo_);
  }
  tboxskinfo_ = tboxskinfo;
  if (tboxskinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusNS.Status.tboxSKInfo)
}
inline ::StatusNS::TboxSKInfo* Status::release_tboxskinfo() {
  
  ::StatusNS::TboxSKInfo* temp = tboxskinfo_;
  tboxskinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::TboxSKInfo* Status::unsafe_arena_release_tboxskinfo() {
  // @@protoc_insertion_point(field_release:StatusNS.Status.tboxSKInfo)
  
  ::StatusNS::TboxSKInfo* temp = tboxskinfo_;
  tboxskinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::TboxSKInfo* Status::_internal_mutable_tboxskinfo() {
  
  if (tboxskinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::TboxSKInfo>(GetArenaForAllocation());
    tboxskinfo_ = p;
  }
  return tboxskinfo_;
}
inline ::StatusNS::TboxSKInfo* Status::mutable_tboxskinfo() {
  ::StatusNS::TboxSKInfo* _msg = _internal_mutable_tboxskinfo();
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.tboxSKInfo)
  return _msg;
}
inline void Status::set_allocated_tboxskinfo(::StatusNS::TboxSKInfo* tboxskinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tboxskinfo_;
  }
  if (tboxskinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatusNS::TboxSKInfo>::GetOwningArena(tboxskinfo);
    if (message_arena != submessage_arena) {
      tboxskinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tboxskinfo, submessage_arena);
    }
    
  } else {
    
  }
  tboxskinfo_ = tboxskinfo;
  // @@protoc_insertion_point(field_set_allocated:StatusNS.Status.tboxSKInfo)
}

// repeated .StatusNS.BmsSKInfo bmsSKInfo = 3;
inline int Status::_internal_bmsskinfo_size() const {
  return bmsskinfo_.size();
}
inline int Status::bmsskinfo_size() const {
  return _internal_bmsskinfo_size();
}
inline void Status::clear_bmsskinfo() {
  bmsskinfo_.Clear();
}
inline ::StatusNS::BmsSKInfo* Status::mutable_bmsskinfo(int index) {
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.bmsSKInfo)
  return bmsskinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::BmsSKInfo >*
Status::mutable_bmsskinfo() {
  // @@protoc_insertion_point(field_mutable_list:StatusNS.Status.bmsSKInfo)
  return &bmsskinfo_;
}
inline const ::StatusNS::BmsSKInfo& Status::_internal_bmsskinfo(int index) const {
  return bmsskinfo_.Get(index);
}
inline const ::StatusNS::BmsSKInfo& Status::bmsskinfo(int index) const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.bmsSKInfo)
  return _internal_bmsskinfo(index);
}
inline ::StatusNS::BmsSKInfo* Status::_internal_add_bmsskinfo() {
  return bmsskinfo_.Add();
}
inline ::StatusNS::BmsSKInfo* Status::add_bmsskinfo() {
  ::StatusNS::BmsSKInfo* _add = _internal_add_bmsskinfo();
  // @@protoc_insertion_point(field_add:StatusNS.Status.bmsSKInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::BmsSKInfo >&
Status::bmsskinfo() const {
  // @@protoc_insertion_point(field_list:StatusNS.Status.bmsSKInfo)
  return bmsskinfo_;
}

// .StatusNS.TboxInfo tboxInfo = 4;
inline bool Status::_internal_has_tboxinfo() const {
  return this != internal_default_instance() && tboxinfo_ != nullptr;
}
inline bool Status::has_tboxinfo() const {
  return _internal_has_tboxinfo();
}
inline void Status::clear_tboxinfo() {
  if (GetArenaForAllocation() == nullptr && tboxinfo_ != nullptr) {
    delete tboxinfo_;
  }
  tboxinfo_ = nullptr;
}
inline const ::StatusNS::TboxInfo& Status::_internal_tboxinfo() const {
  const ::StatusNS::TboxInfo* p = tboxinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::TboxInfo&>(
      ::StatusNS::_TboxInfo_default_instance_);
}
inline const ::StatusNS::TboxInfo& Status::tboxinfo() const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.tboxInfo)
  return _internal_tboxinfo();
}
inline void Status::unsafe_arena_set_allocated_tboxinfo(
    ::StatusNS::TboxInfo* tboxinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tboxinfo_);
  }
  tboxinfo_ = tboxinfo;
  if (tboxinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusNS.Status.tboxInfo)
}
inline ::StatusNS::TboxInfo* Status::release_tboxinfo() {
  
  ::StatusNS::TboxInfo* temp = tboxinfo_;
  tboxinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::TboxInfo* Status::unsafe_arena_release_tboxinfo() {
  // @@protoc_insertion_point(field_release:StatusNS.Status.tboxInfo)
  
  ::StatusNS::TboxInfo* temp = tboxinfo_;
  tboxinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::TboxInfo* Status::_internal_mutable_tboxinfo() {
  
  if (tboxinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::TboxInfo>(GetArenaForAllocation());
    tboxinfo_ = p;
  }
  return tboxinfo_;
}
inline ::StatusNS::TboxInfo* Status::mutable_tboxinfo() {
  ::StatusNS::TboxInfo* _msg = _internal_mutable_tboxinfo();
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.tboxInfo)
  return _msg;
}
inline void Status::set_allocated_tboxinfo(::StatusNS::TboxInfo* tboxinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tboxinfo_;
  }
  if (tboxinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatusNS::TboxInfo>::GetOwningArena(tboxinfo);
    if (message_arena != submessage_arena) {
      tboxinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tboxinfo, submessage_arena);
    }
    
  } else {
    
  }
  tboxinfo_ = tboxinfo;
  // @@protoc_insertion_point(field_set_allocated:StatusNS.Status.tboxInfo)
}

// .StatusNS.BmsInfo bmsInfo = 5;
inline bool Status::_internal_has_bmsinfo() const {
  return this != internal_default_instance() && bmsinfo_ != nullptr;
}
inline bool Status::has_bmsinfo() const {
  return _internal_has_bmsinfo();
}
inline void Status::clear_bmsinfo() {
  if (GetArenaForAllocation() == nullptr && bmsinfo_ != nullptr) {
    delete bmsinfo_;
  }
  bmsinfo_ = nullptr;
}
inline const ::StatusNS::BmsInfo& Status::_internal_bmsinfo() const {
  const ::StatusNS::BmsInfo* p = bmsinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::BmsInfo&>(
      ::StatusNS::_BmsInfo_default_instance_);
}
inline const ::StatusNS::BmsInfo& Status::bmsinfo() const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.bmsInfo)
  return _internal_bmsinfo();
}
inline void Status::unsafe_arena_set_allocated_bmsinfo(
    ::StatusNS::BmsInfo* bmsinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bmsinfo_);
  }
  bmsinfo_ = bmsinfo;
  if (bmsinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusNS.Status.bmsInfo)
}
inline ::StatusNS::BmsInfo* Status::release_bmsinfo() {
  
  ::StatusNS::BmsInfo* temp = bmsinfo_;
  bmsinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::BmsInfo* Status::unsafe_arena_release_bmsinfo() {
  // @@protoc_insertion_point(field_release:StatusNS.Status.bmsInfo)
  
  ::StatusNS::BmsInfo* temp = bmsinfo_;
  bmsinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::BmsInfo* Status::_internal_mutable_bmsinfo() {
  
  if (bmsinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::BmsInfo>(GetArenaForAllocation());
    bmsinfo_ = p;
  }
  return bmsinfo_;
}
inline ::StatusNS::BmsInfo* Status::mutable_bmsinfo() {
  ::StatusNS::BmsInfo* _msg = _internal_mutable_bmsinfo();
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.bmsInfo)
  return _msg;
}
inline void Status::set_allocated_bmsinfo(::StatusNS::BmsInfo* bmsinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bmsinfo_;
  }
  if (bmsinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatusNS::BmsInfo>::GetOwningArena(bmsinfo);
    if (message_arena != submessage_arena) {
      bmsinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bmsinfo, submessage_arena);
    }
    
  } else {
    
  }
  bmsinfo_ = bmsinfo;
  // @@protoc_insertion_point(field_set_allocated:StatusNS.Status.bmsInfo)
}

// .StatusNS.TpmsInfo tpmsInfo = 6;
inline bool Status::_internal_has_tpmsinfo() const {
  return this != internal_default_instance() && tpmsinfo_ != nullptr;
}
inline bool Status::has_tpmsinfo() const {
  return _internal_has_tpmsinfo();
}
inline void Status::clear_tpmsinfo() {
  if (GetArenaForAllocation() == nullptr && tpmsinfo_ != nullptr) {
    delete tpmsinfo_;
  }
  tpmsinfo_ = nullptr;
}
inline const ::StatusNS::TpmsInfo& Status::_internal_tpmsinfo() const {
  const ::StatusNS::TpmsInfo* p = tpmsinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::StatusNS::TpmsInfo&>(
      ::StatusNS::_TpmsInfo_default_instance_);
}
inline const ::StatusNS::TpmsInfo& Status::tpmsinfo() const {
  // @@protoc_insertion_point(field_get:StatusNS.Status.tpmsInfo)
  return _internal_tpmsinfo();
}
inline void Status::unsafe_arena_set_allocated_tpmsinfo(
    ::StatusNS::TpmsInfo* tpmsinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tpmsinfo_);
  }
  tpmsinfo_ = tpmsinfo;
  if (tpmsinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusNS.Status.tpmsInfo)
}
inline ::StatusNS::TpmsInfo* Status::release_tpmsinfo() {
  
  ::StatusNS::TpmsInfo* temp = tpmsinfo_;
  tpmsinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StatusNS::TpmsInfo* Status::unsafe_arena_release_tpmsinfo() {
  // @@protoc_insertion_point(field_release:StatusNS.Status.tpmsInfo)
  
  ::StatusNS::TpmsInfo* temp = tpmsinfo_;
  tpmsinfo_ = nullptr;
  return temp;
}
inline ::StatusNS::TpmsInfo* Status::_internal_mutable_tpmsinfo() {
  
  if (tpmsinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatusNS::TpmsInfo>(GetArenaForAllocation());
    tpmsinfo_ = p;
  }
  return tpmsinfo_;
}
inline ::StatusNS::TpmsInfo* Status::mutable_tpmsinfo() {
  ::StatusNS::TpmsInfo* _msg = _internal_mutable_tpmsinfo();
  // @@protoc_insertion_point(field_mutable:StatusNS.Status.tpmsInfo)
  return _msg;
}
inline void Status::set_allocated_tpmsinfo(::StatusNS::TpmsInfo* tpmsinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tpmsinfo_;
  }
  if (tpmsinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StatusNS::TpmsInfo>::GetOwningArena(tpmsinfo);
    if (message_arena != submessage_arena) {
      tpmsinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tpmsinfo, submessage_arena);
    }
    
  } else {
    
  }
  tpmsinfo_ = tpmsinfo;
  // @@protoc_insertion_point(field_set_allocated:StatusNS.Status.tpmsInfo)
}

// -------------------------------------------------------------------

// HmiInfo

// uint32 odoMetro = 1;
inline void HmiInfo::clear_odometro() {
  odometro_ = 0u;
}
inline uint32_t HmiInfo::_internal_odometro() const {
  return odometro_;
}
inline uint32_t HmiInfo::odometro() const {
  // @@protoc_insertion_point(field_get:StatusNS.HmiInfo.odoMetro)
  return _internal_odometro();
}
inline void HmiInfo::_internal_set_odometro(uint32_t value) {
  
  odometro_ = value;
}
inline void HmiInfo::set_odometro(uint32_t value) {
  _internal_set_odometro(value);
  // @@protoc_insertion_point(field_set:StatusNS.HmiInfo.odoMetro)
}

// uint32 enduranceMileage = 2;
inline void HmiInfo::clear_endurancemileage() {
  endurancemileage_ = 0u;
}
inline uint32_t HmiInfo::_internal_endurancemileage() const {
  return endurancemileage_;
}
inline uint32_t HmiInfo::endurancemileage() const {
  // @@protoc_insertion_point(field_get:StatusNS.HmiInfo.enduranceMileage)
  return _internal_endurancemileage();
}
inline void HmiInfo::_internal_set_endurancemileage(uint32_t value) {
  
  endurancemileage_ = value;
}
inline void HmiInfo::set_endurancemileage(uint32_t value) {
  _internal_set_endurancemileage(value);
  // @@protoc_insertion_point(field_set:StatusNS.HmiInfo.enduranceMileage)
}

// uint32 speed = 3;
inline void HmiInfo::clear_speed() {
  speed_ = 0u;
}
inline uint32_t HmiInfo::_internal_speed() const {
  return speed_;
}
inline uint32_t HmiInfo::speed() const {
  // @@protoc_insertion_point(field_get:StatusNS.HmiInfo.speed)
  return _internal_speed();
}
inline void HmiInfo::_internal_set_speed(uint32_t value) {
  
  speed_ = value;
}
inline void HmiInfo::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:StatusNS.HmiInfo.speed)
}

// uint32 revSpeed = 4;
inline void HmiInfo::clear_revspeed() {
  revspeed_ = 0u;
}
inline uint32_t HmiInfo::_internal_revspeed() const {
  return revspeed_;
}
inline uint32_t HmiInfo::revspeed() const {
  // @@protoc_insertion_point(field_get:StatusNS.HmiInfo.revSpeed)
  return _internal_revspeed();
}
inline void HmiInfo::_internal_set_revspeed(uint32_t value) {
  
  revspeed_ = value;
}
inline void HmiInfo::set_revspeed(uint32_t value) {
  _internal_set_revspeed(value);
  // @@protoc_insertion_point(field_set:StatusNS.HmiInfo.revSpeed)
}

// .StatusNS.GearPosition gearPosition = 5;
inline void HmiInfo::clear_gearposition() {
  gearposition_ = 0;
}
inline ::StatusNS::GearPosition HmiInfo::_internal_gearposition() const {
  return static_cast< ::StatusNS::GearPosition >(gearposition_);
}
inline ::StatusNS::GearPosition HmiInfo::gearposition() const {
  // @@protoc_insertion_point(field_get:StatusNS.HmiInfo.gearPosition)
  return _internal_gearposition();
}
inline void HmiInfo::_internal_set_gearposition(::StatusNS::GearPosition value) {
  
  gearposition_ = value;
}
inline void HmiInfo::set_gearposition(::StatusNS::GearPosition value) {
  _internal_set_gearposition(value);
  // @@protoc_insertion_point(field_set:StatusNS.HmiInfo.gearPosition)
}

// -------------------------------------------------------------------

// BmsSKInfo

// uint32 bmsVoltage = 1;
inline void BmsSKInfo::clear_bmsvoltage() {
  bmsvoltage_ = 0u;
}
inline uint32_t BmsSKInfo::_internal_bmsvoltage() const {
  return bmsvoltage_;
}
inline uint32_t BmsSKInfo::bmsvoltage() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsSKInfo.bmsVoltage)
  return _internal_bmsvoltage();
}
inline void BmsSKInfo::_internal_set_bmsvoltage(uint32_t value) {
  
  bmsvoltage_ = value;
}
inline void BmsSKInfo::set_bmsvoltage(uint32_t value) {
  _internal_set_bmsvoltage(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsSKInfo.bmsVoltage)
}

// uint32 bmsElectric = 2;
inline void BmsSKInfo::clear_bmselectric() {
  bmselectric_ = 0u;
}
inline uint32_t BmsSKInfo::_internal_bmselectric() const {
  return bmselectric_;
}
inline uint32_t BmsSKInfo::bmselectric() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsSKInfo.bmsElectric)
  return _internal_bmselectric();
}
inline void BmsSKInfo::_internal_set_bmselectric(uint32_t value) {
  
  bmselectric_ = value;
}
inline void BmsSKInfo::set_bmselectric(uint32_t value) {
  _internal_set_bmselectric(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsSKInfo.bmsElectric)
}

// uint32 bmsSOC = 3;
inline void BmsSKInfo::clear_bmssoc() {
  bmssoc_ = 0u;
}
inline uint32_t BmsSKInfo::_internal_bmssoc() const {
  return bmssoc_;
}
inline uint32_t BmsSKInfo::bmssoc() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsSKInfo.bmsSOC)
  return _internal_bmssoc();
}
inline void BmsSKInfo::_internal_set_bmssoc(uint32_t value) {
  
  bmssoc_ = value;
}
inline void BmsSKInfo::set_bmssoc(uint32_t value) {
  _internal_set_bmssoc(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsSKInfo.bmsSOC)
}

// uint32 bmsTemp = 4;
inline void BmsSKInfo::clear_bmstemp() {
  bmstemp_ = 0u;
}
inline uint32_t BmsSKInfo::_internal_bmstemp() const {
  return bmstemp_;
}
inline uint32_t BmsSKInfo::bmstemp() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsSKInfo.bmsTemp)
  return _internal_bmstemp();
}
inline void BmsSKInfo::_internal_set_bmstemp(uint32_t value) {
  
  bmstemp_ = value;
}
inline void BmsSKInfo::set_bmstemp(uint32_t value) {
  _internal_set_bmstemp(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsSKInfo.bmsTemp)
}

// -------------------------------------------------------------------

// BmsInfo

// uint32 bmsVoltage = 1;
inline void BmsInfo::clear_bmsvoltage() {
  bmsvoltage_ = 0u;
}
inline uint32_t BmsInfo::_internal_bmsvoltage() const {
  return bmsvoltage_;
}
inline uint32_t BmsInfo::bmsvoltage() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsInfo.bmsVoltage)
  return _internal_bmsvoltage();
}
inline void BmsInfo::_internal_set_bmsvoltage(uint32_t value) {
  
  bmsvoltage_ = value;
}
inline void BmsInfo::set_bmsvoltage(uint32_t value) {
  _internal_set_bmsvoltage(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsInfo.bmsVoltage)
}

// uint32 bmsElectric = 2;
inline void BmsInfo::clear_bmselectric() {
  bmselectric_ = 0u;
}
inline uint32_t BmsInfo::_internal_bmselectric() const {
  return bmselectric_;
}
inline uint32_t BmsInfo::bmselectric() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsInfo.bmsElectric)
  return _internal_bmselectric();
}
inline void BmsInfo::_internal_set_bmselectric(uint32_t value) {
  
  bmselectric_ = value;
}
inline void BmsInfo::set_bmselectric(uint32_t value) {
  _internal_set_bmselectric(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsInfo.bmsElectric)
}

// uint32 bmsSOC = 3;
inline void BmsInfo::clear_bmssoc() {
  bmssoc_ = 0u;
}
inline uint32_t BmsInfo::_internal_bmssoc() const {
  return bmssoc_;
}
inline uint32_t BmsInfo::bmssoc() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsInfo.bmsSOC)
  return _internal_bmssoc();
}
inline void BmsInfo::_internal_set_bmssoc(uint32_t value) {
  
  bmssoc_ = value;
}
inline void BmsInfo::set_bmssoc(uint32_t value) {
  _internal_set_bmssoc(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsInfo.bmsSOC)
}

// uint32 bmsTemp = 4;
inline void BmsInfo::clear_bmstemp() {
  bmstemp_ = 0u;
}
inline uint32_t BmsInfo::_internal_bmstemp() const {
  return bmstemp_;
}
inline uint32_t BmsInfo::bmstemp() const {
  // @@protoc_insertion_point(field_get:StatusNS.BmsInfo.bmsTemp)
  return _internal_bmstemp();
}
inline void BmsInfo::_internal_set_bmstemp(uint32_t value) {
  
  bmstemp_ = value;
}
inline void BmsInfo::set_bmstemp(uint32_t value) {
  _internal_set_bmstemp(value);
  // @@protoc_insertion_point(field_set:StatusNS.BmsInfo.bmsTemp)
}

// -------------------------------------------------------------------

// TboxSKInfo

// bool kl15 = 1;
inline void TboxSKInfo::clear_kl15() {
  kl15_ = false;
}
inline bool TboxSKInfo::_internal_kl15() const {
  return kl15_;
}
inline bool TboxSKInfo::kl15() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.kl15)
  return _internal_kl15();
}
inline void TboxSKInfo::_internal_set_kl15(bool value) {
  
  kl15_ = value;
}
inline void TboxSKInfo::set_kl15(bool value) {
  _internal_set_kl15(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.kl15)
}

// uint32 kl30 = 2;
inline void TboxSKInfo::clear_kl30() {
  kl30_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_kl30() const {
  return kl30_;
}
inline uint32_t TboxSKInfo::kl30() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.kl30)
  return _internal_kl30();
}
inline void TboxSKInfo::_internal_set_kl30(uint32_t value) {
  
  kl30_ = value;
}
inline void TboxSKInfo::set_kl30(uint32_t value) {
  _internal_set_kl30(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.kl30)
}

// uint32 batteryVoltage = 3;
inline void TboxSKInfo::clear_batteryvoltage() {
  batteryvoltage_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_batteryvoltage() const {
  return batteryvoltage_;
}
inline uint32_t TboxSKInfo::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.batteryVoltage)
  return _internal_batteryvoltage();
}
inline void TboxSKInfo::_internal_set_batteryvoltage(uint32_t value) {
  
  batteryvoltage_ = value;
}
inline void TboxSKInfo::set_batteryvoltage(uint32_t value) {
  _internal_set_batteryvoltage(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.batteryVoltage)
}

// uint32 csq = 4;
inline void TboxSKInfo::clear_csq() {
  csq_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_csq() const {
  return csq_;
}
inline uint32_t TboxSKInfo::csq() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.csq)
  return _internal_csq();
}
inline void TboxSKInfo::_internal_set_csq(uint32_t value) {
  
  csq_ = value;
}
inline void TboxSKInfo::set_csq(uint32_t value) {
  _internal_set_csq(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.csq)
}

// repeated .StatusNS.CanInfo canInfo = 5;
inline int TboxSKInfo::_internal_caninfo_size() const {
  return caninfo_.size();
}
inline int TboxSKInfo::caninfo_size() const {
  return _internal_caninfo_size();
}
inline void TboxSKInfo::clear_caninfo() {
  caninfo_.Clear();
}
inline ::StatusNS::CanInfo* TboxSKInfo::mutable_caninfo(int index) {
  // @@protoc_insertion_point(field_mutable:StatusNS.TboxSKInfo.canInfo)
  return caninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >*
TboxSKInfo::mutable_caninfo() {
  // @@protoc_insertion_point(field_mutable_list:StatusNS.TboxSKInfo.canInfo)
  return &caninfo_;
}
inline const ::StatusNS::CanInfo& TboxSKInfo::_internal_caninfo(int index) const {
  return caninfo_.Get(index);
}
inline const ::StatusNS::CanInfo& TboxSKInfo::caninfo(int index) const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.canInfo)
  return _internal_caninfo(index);
}
inline ::StatusNS::CanInfo* TboxSKInfo::_internal_add_caninfo() {
  return caninfo_.Add();
}
inline ::StatusNS::CanInfo* TboxSKInfo::add_caninfo() {
  ::StatusNS::CanInfo* _add = _internal_add_caninfo();
  // @@protoc_insertion_point(field_add:StatusNS.TboxSKInfo.canInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >&
TboxSKInfo::caninfo() const {
  // @@protoc_insertion_point(field_list:StatusNS.TboxSKInfo.canInfo)
  return caninfo_;
}

// bytes location = 6;
inline void TboxSKInfo::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& TboxSKInfo::location() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TboxSKInfo::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.location)
}
inline std::string* TboxSKInfo::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:StatusNS.TboxSKInfo.location)
  return _s;
}
inline const std::string& TboxSKInfo::_internal_location() const {
  return location_.Get();
}
inline void TboxSKInfo::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TboxSKInfo::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TboxSKInfo::release_location() {
  // @@protoc_insertion_point(field_release:StatusNS.TboxSKInfo.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TboxSKInfo::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StatusNS.TboxSKInfo.location)
}

// uint32 rapidAccelerationCount = 7;
inline void TboxSKInfo::clear_rapidaccelerationcount() {
  rapidaccelerationcount_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_rapidaccelerationcount() const {
  return rapidaccelerationcount_;
}
inline uint32_t TboxSKInfo::rapidaccelerationcount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.rapidAccelerationCount)
  return _internal_rapidaccelerationcount();
}
inline void TboxSKInfo::_internal_set_rapidaccelerationcount(uint32_t value) {
  
  rapidaccelerationcount_ = value;
}
inline void TboxSKInfo::set_rapidaccelerationcount(uint32_t value) {
  _internal_set_rapidaccelerationcount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.rapidAccelerationCount)
}

// uint32 rapidDecelerationCount = 8;
inline void TboxSKInfo::clear_rapiddecelerationcount() {
  rapiddecelerationcount_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_rapiddecelerationcount() const {
  return rapiddecelerationcount_;
}
inline uint32_t TboxSKInfo::rapiddecelerationcount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.rapidDecelerationCount)
  return _internal_rapiddecelerationcount();
}
inline void TboxSKInfo::_internal_set_rapiddecelerationcount(uint32_t value) {
  
  rapiddecelerationcount_ = value;
}
inline void TboxSKInfo::set_rapiddecelerationcount(uint32_t value) {
  _internal_set_rapiddecelerationcount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.rapidDecelerationCount)
}

// uint32 emergencyBrakeCount = 9;
inline void TboxSKInfo::clear_emergencybrakecount() {
  emergencybrakecount_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_emergencybrakecount() const {
  return emergencybrakecount_;
}
inline uint32_t TboxSKInfo::emergencybrakecount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.emergencyBrakeCount)
  return _internal_emergencybrakecount();
}
inline void TboxSKInfo::_internal_set_emergencybrakecount(uint32_t value) {
  
  emergencybrakecount_ = value;
}
inline void TboxSKInfo::set_emergencybrakecount(uint32_t value) {
  _internal_set_emergencybrakecount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.emergencyBrakeCount)
}

// uint32 sharpTurnCount = 10;
inline void TboxSKInfo::clear_sharpturncount() {
  sharpturncount_ = 0u;
}
inline uint32_t TboxSKInfo::_internal_sharpturncount() const {
  return sharpturncount_;
}
inline uint32_t TboxSKInfo::sharpturncount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxSKInfo.sharpTurnCount)
  return _internal_sharpturncount();
}
inline void TboxSKInfo::_internal_set_sharpturncount(uint32_t value) {
  
  sharpturncount_ = value;
}
inline void TboxSKInfo::set_sharpturncount(uint32_t value) {
  _internal_set_sharpturncount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxSKInfo.sharpTurnCount)
}

// -------------------------------------------------------------------

// TboxInfo

// bool kl15 = 1;
inline void TboxInfo::clear_kl15() {
  kl15_ = false;
}
inline bool TboxInfo::_internal_kl15() const {
  return kl15_;
}
inline bool TboxInfo::kl15() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.kl15)
  return _internal_kl15();
}
inline void TboxInfo::_internal_set_kl15(bool value) {
  
  kl15_ = value;
}
inline void TboxInfo::set_kl15(bool value) {
  _internal_set_kl15(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.kl15)
}

// uint32 kl30 = 2;
inline void TboxInfo::clear_kl30() {
  kl30_ = 0u;
}
inline uint32_t TboxInfo::_internal_kl30() const {
  return kl30_;
}
inline uint32_t TboxInfo::kl30() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.kl30)
  return _internal_kl30();
}
inline void TboxInfo::_internal_set_kl30(uint32_t value) {
  
  kl30_ = value;
}
inline void TboxInfo::set_kl30(uint32_t value) {
  _internal_set_kl30(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.kl30)
}

// uint32 batteryVoltage = 3;
inline void TboxInfo::clear_batteryvoltage() {
  batteryvoltage_ = 0u;
}
inline uint32_t TboxInfo::_internal_batteryvoltage() const {
  return batteryvoltage_;
}
inline uint32_t TboxInfo::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.batteryVoltage)
  return _internal_batteryvoltage();
}
inline void TboxInfo::_internal_set_batteryvoltage(uint32_t value) {
  
  batteryvoltage_ = value;
}
inline void TboxInfo::set_batteryvoltage(uint32_t value) {
  _internal_set_batteryvoltage(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.batteryVoltage)
}

// uint32 csq = 4;
inline void TboxInfo::clear_csq() {
  csq_ = 0u;
}
inline uint32_t TboxInfo::_internal_csq() const {
  return csq_;
}
inline uint32_t TboxInfo::csq() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.csq)
  return _internal_csq();
}
inline void TboxInfo::_internal_set_csq(uint32_t value) {
  
  csq_ = value;
}
inline void TboxInfo::set_csq(uint32_t value) {
  _internal_set_csq(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.csq)
}

// repeated .StatusNS.CanInfo canInfo = 5;
inline int TboxInfo::_internal_caninfo_size() const {
  return caninfo_.size();
}
inline int TboxInfo::caninfo_size() const {
  return _internal_caninfo_size();
}
inline void TboxInfo::clear_caninfo() {
  caninfo_.Clear();
}
inline ::StatusNS::CanInfo* TboxInfo::mutable_caninfo(int index) {
  // @@protoc_insertion_point(field_mutable:StatusNS.TboxInfo.canInfo)
  return caninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >*
TboxInfo::mutable_caninfo() {
  // @@protoc_insertion_point(field_mutable_list:StatusNS.TboxInfo.canInfo)
  return &caninfo_;
}
inline const ::StatusNS::CanInfo& TboxInfo::_internal_caninfo(int index) const {
  return caninfo_.Get(index);
}
inline const ::StatusNS::CanInfo& TboxInfo::caninfo(int index) const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.canInfo)
  return _internal_caninfo(index);
}
inline ::StatusNS::CanInfo* TboxInfo::_internal_add_caninfo() {
  return caninfo_.Add();
}
inline ::StatusNS::CanInfo* TboxInfo::add_caninfo() {
  ::StatusNS::CanInfo* _add = _internal_add_caninfo();
  // @@protoc_insertion_point(field_add:StatusNS.TboxInfo.canInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StatusNS::CanInfo >&
TboxInfo::caninfo() const {
  // @@protoc_insertion_point(field_list:StatusNS.TboxInfo.canInfo)
  return caninfo_;
}

// bytes location = 6;
inline void TboxInfo::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& TboxInfo::location() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TboxInfo::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.location)
}
inline std::string* TboxInfo::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:StatusNS.TboxInfo.location)
  return _s;
}
inline const std::string& TboxInfo::_internal_location() const {
  return location_.Get();
}
inline void TboxInfo::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TboxInfo::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TboxInfo::release_location() {
  // @@protoc_insertion_point(field_release:StatusNS.TboxInfo.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TboxInfo::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StatusNS.TboxInfo.location)
}

// uint32 rapidAccelerationCount = 7;
inline void TboxInfo::clear_rapidaccelerationcount() {
  rapidaccelerationcount_ = 0u;
}
inline uint32_t TboxInfo::_internal_rapidaccelerationcount() const {
  return rapidaccelerationcount_;
}
inline uint32_t TboxInfo::rapidaccelerationcount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.rapidAccelerationCount)
  return _internal_rapidaccelerationcount();
}
inline void TboxInfo::_internal_set_rapidaccelerationcount(uint32_t value) {
  
  rapidaccelerationcount_ = value;
}
inline void TboxInfo::set_rapidaccelerationcount(uint32_t value) {
  _internal_set_rapidaccelerationcount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.rapidAccelerationCount)
}

// uint32 rapidDecelerationCount = 8;
inline void TboxInfo::clear_rapiddecelerationcount() {
  rapiddecelerationcount_ = 0u;
}
inline uint32_t TboxInfo::_internal_rapiddecelerationcount() const {
  return rapiddecelerationcount_;
}
inline uint32_t TboxInfo::rapiddecelerationcount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.rapidDecelerationCount)
  return _internal_rapiddecelerationcount();
}
inline void TboxInfo::_internal_set_rapiddecelerationcount(uint32_t value) {
  
  rapiddecelerationcount_ = value;
}
inline void TboxInfo::set_rapiddecelerationcount(uint32_t value) {
  _internal_set_rapiddecelerationcount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.rapidDecelerationCount)
}

// uint32 emergencyBrakeCount = 9;
inline void TboxInfo::clear_emergencybrakecount() {
  emergencybrakecount_ = 0u;
}
inline uint32_t TboxInfo::_internal_emergencybrakecount() const {
  return emergencybrakecount_;
}
inline uint32_t TboxInfo::emergencybrakecount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.emergencyBrakeCount)
  return _internal_emergencybrakecount();
}
inline void TboxInfo::_internal_set_emergencybrakecount(uint32_t value) {
  
  emergencybrakecount_ = value;
}
inline void TboxInfo::set_emergencybrakecount(uint32_t value) {
  _internal_set_emergencybrakecount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.emergencyBrakeCount)
}

// uint32 sharpTurnCount = 10;
inline void TboxInfo::clear_sharpturncount() {
  sharpturncount_ = 0u;
}
inline uint32_t TboxInfo::_internal_sharpturncount() const {
  return sharpturncount_;
}
inline uint32_t TboxInfo::sharpturncount() const {
  // @@protoc_insertion_point(field_get:StatusNS.TboxInfo.sharpTurnCount)
  return _internal_sharpturncount();
}
inline void TboxInfo::_internal_set_sharpturncount(uint32_t value) {
  
  sharpturncount_ = value;
}
inline void TboxInfo::set_sharpturncount(uint32_t value) {
  _internal_set_sharpturncount(value);
  // @@protoc_insertion_point(field_set:StatusNS.TboxInfo.sharpTurnCount)
}

// -------------------------------------------------------------------

// TpmsInfo

// int32 frontTierTemp = 1;
inline void TpmsInfo::clear_fronttiertemp() {
  fronttiertemp_ = 0;
}
inline int32_t TpmsInfo::_internal_fronttiertemp() const {
  return fronttiertemp_;
}
inline int32_t TpmsInfo::fronttiertemp() const {
  // @@protoc_insertion_point(field_get:StatusNS.TpmsInfo.frontTierTemp)
  return _internal_fronttiertemp();
}
inline void TpmsInfo::_internal_set_fronttiertemp(int32_t value) {
  
  fronttiertemp_ = value;
}
inline void TpmsInfo::set_fronttiertemp(int32_t value) {
  _internal_set_fronttiertemp(value);
  // @@protoc_insertion_point(field_set:StatusNS.TpmsInfo.frontTierTemp)
}

// int32 rearTireTemp = 2;
inline void TpmsInfo::clear_reartiretemp() {
  reartiretemp_ = 0;
}
inline int32_t TpmsInfo::_internal_reartiretemp() const {
  return reartiretemp_;
}
inline int32_t TpmsInfo::reartiretemp() const {
  // @@protoc_insertion_point(field_get:StatusNS.TpmsInfo.rearTireTemp)
  return _internal_reartiretemp();
}
inline void TpmsInfo::_internal_set_reartiretemp(int32_t value) {
  
  reartiretemp_ = value;
}
inline void TpmsInfo::set_reartiretemp(int32_t value) {
  _internal_set_reartiretemp(value);
  // @@protoc_insertion_point(field_set:StatusNS.TpmsInfo.rearTireTemp)
}

// int32 frontTirePressure = 3;
inline void TpmsInfo::clear_fronttirepressure() {
  fronttirepressure_ = 0;
}
inline int32_t TpmsInfo::_internal_fronttirepressure() const {
  return fronttirepressure_;
}
inline int32_t TpmsInfo::fronttirepressure() const {
  // @@protoc_insertion_point(field_get:StatusNS.TpmsInfo.frontTirePressure)
  return _internal_fronttirepressure();
}
inline void TpmsInfo::_internal_set_fronttirepressure(int32_t value) {
  
  fronttirepressure_ = value;
}
inline void TpmsInfo::set_fronttirepressure(int32_t value) {
  _internal_set_fronttirepressure(value);
  // @@protoc_insertion_point(field_set:StatusNS.TpmsInfo.frontTirePressure)
}

// int32 rearTirePressure = 4;
inline void TpmsInfo::clear_reartirepressure() {
  reartirepressure_ = 0;
}
inline int32_t TpmsInfo::_internal_reartirepressure() const {
  return reartirepressure_;
}
inline int32_t TpmsInfo::reartirepressure() const {
  // @@protoc_insertion_point(field_get:StatusNS.TpmsInfo.rearTirePressure)
  return _internal_reartirepressure();
}
inline void TpmsInfo::_internal_set_reartirepressure(int32_t value) {
  
  reartirepressure_ = value;
}
inline void TpmsInfo::set_reartirepressure(int32_t value) {
  _internal_set_reartirepressure(value);
  // @@protoc_insertion_point(field_set:StatusNS.TpmsInfo.rearTirePressure)
}

// uint32 status = 5;
inline void TpmsInfo::clear_status() {
  status_ = 0u;
}
inline uint32_t TpmsInfo::_internal_status() const {
  return status_;
}
inline uint32_t TpmsInfo::status() const {
  // @@protoc_insertion_point(field_get:StatusNS.TpmsInfo.status)
  return _internal_status();
}
inline void TpmsInfo::_internal_set_status(uint32_t value) {
  
  status_ = value;
}
inline void TpmsInfo::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:StatusNS.TpmsInfo.status)
}

// -------------------------------------------------------------------

// CanInfo

// uint32 canChannel = 1;
inline void CanInfo::clear_canchannel() {
  canchannel_ = 0u;
}
inline uint32_t CanInfo::_internal_canchannel() const {
  return canchannel_;
}
inline uint32_t CanInfo::canchannel() const {
  // @@protoc_insertion_point(field_get:StatusNS.CanInfo.canChannel)
  return _internal_canchannel();
}
inline void CanInfo::_internal_set_canchannel(uint32_t value) {
  
  canchannel_ = value;
}
inline void CanInfo::set_canchannel(uint32_t value) {
  _internal_set_canchannel(value);
  // @@protoc_insertion_point(field_set:StatusNS.CanInfo.canChannel)
}

// bool busOff = 2;
inline void CanInfo::clear_busoff() {
  busoff_ = false;
}
inline bool CanInfo::_internal_busoff() const {
  return busoff_;
}
inline bool CanInfo::busoff() const {
  // @@protoc_insertion_point(field_get:StatusNS.CanInfo.busOff)
  return _internal_busoff();
}
inline void CanInfo::_internal_set_busoff(bool value) {
  
  busoff_ = value;
}
inline void CanInfo::set_busoff(bool value) {
  _internal_set_busoff(value);
  // @@protoc_insertion_point(field_set:StatusNS.CanInfo.busOff)
}

// bool noAck = 3;
inline void CanInfo::clear_noack() {
  noack_ = false;
}
inline bool CanInfo::_internal_noack() const {
  return noack_;
}
inline bool CanInfo::noack() const {
  // @@protoc_insertion_point(field_get:StatusNS.CanInfo.noAck)
  return _internal_noack();
}
inline void CanInfo::_internal_set_noack(bool value) {
  
  noack_ = value;
}
inline void CanInfo::set_noack(bool value) {
  _internal_set_noack(value);
  // @@protoc_insertion_point(field_set:StatusNS.CanInfo.noAck)
}

// uint32 sendNum = 4;
inline void CanInfo::clear_sendnum() {
  sendnum_ = 0u;
}
inline uint32_t CanInfo::_internal_sendnum() const {
  return sendnum_;
}
inline uint32_t CanInfo::sendnum() const {
  // @@protoc_insertion_point(field_get:StatusNS.CanInfo.sendNum)
  return _internal_sendnum();
}
inline void CanInfo::_internal_set_sendnum(uint32_t value) {
  
  sendnum_ = value;
}
inline void CanInfo::set_sendnum(uint32_t value) {
  _internal_set_sendnum(value);
  // @@protoc_insertion_point(field_set:StatusNS.CanInfo.sendNum)
}

// uint32 recvNum = 5;
inline void CanInfo::clear_recvnum() {
  recvnum_ = 0u;
}
inline uint32_t CanInfo::_internal_recvnum() const {
  return recvnum_;
}
inline uint32_t CanInfo::recvnum() const {
  // @@protoc_insertion_point(field_get:StatusNS.CanInfo.recvNum)
  return _internal_recvnum();
}
inline void CanInfo::_internal_set_recvnum(uint32_t value) {
  
  recvnum_ = value;
}
inline void CanInfo::set_recvnum(uint32_t value) {
  _internal_set_recvnum(value);
  // @@protoc_insertion_point(field_set:StatusNS.CanInfo.recvNum)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace StatusNS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::StatusNS::GearPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StatusNS::GearPosition>() {
  return ::StatusNS::GearPosition_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_status_2eproto
