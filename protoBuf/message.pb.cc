// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace MessageNS {
constexpr Message::Message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : connection_(nullptr)
  , status_(nullptr)
  , control_(nullptr)
  , diagnose_(nullptr)
  , alert_(nullptr)
  , fault_(nullptr)
  , analysis_(nullptr)
  , gb32960_(nullptr)
  , lock_(nullptr)
  , event_(nullptr)
  , ota_(nullptr)
  , otastep_(nullptr)
  , aid_(0)
{}
struct MessageDefaultTypeInternal {
  constexpr MessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace MessageNS
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_message_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_message_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_message_2eproto = nullptr;

const uint32_t TableStruct_message_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, aid_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, connection_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, status_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, control_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, diagnose_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, alert_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, fault_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, analysis_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, gb32960_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, lock_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, event_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, ota_),
  PROTOBUF_FIELD_OFFSET(::MessageNS::Message, otastep_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::MessageNS::Message)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::MessageNS::_Message_default_instance_),
};

const char descriptor_table_protodef_message_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rmessage.proto\022\tMessageNS\032\020connection.p"
  "roto\032\014status.proto\032\rcontrol.proto\032\016diagn"
  "ose.proto\032\013alert.proto\032\013fault.proto\032\016ana"
  "lysis.proto\032\rgb32960.proto\032\nlock.proto\032\013"
  "event.proto\032\tota.proto\"\303\003\n\007Message\022\033\n\003ai"
  "d\030\001 \001(\0162\016.MessageNS.Aid\022,\n\nconnection\030\002 "
  "\001(\0132\030.ConnectionNS.Connection\022 \n\006status\030"
  "\003 \001(\0132\020.StatusNS.Status\022#\n\007control\030\004 \001(\013"
  "2\022.ControlNS.Control\022&\n\010diagnose\030\005 \001(\0132\024"
  ".DiagnoseNS.Diagnose\022\035\n\005alert\030\006 \001(\0132\016.Al"
  "ertNS.Alert\022\035\n\005fault\030\007 \001(\0132\016.FaultNS.Fau"
  "lt\022&\n\010analysis\030\010 \001(\0132\024.AnalysisNS.Analys"
  "is\022#\n\007gb32960\030\t \001(\0132\022.Gb32960NS.Gb32960\022"
  "\032\n\004lock\030\n \001(\0132\014.LockNS.Lock\022\035\n\005event\030\013 \001"
  "(\0132\016.EventNS.Event\022\027\n\003ota\030\014 \001(\0132\n.OTANS."
  "OTA\022\037\n\007otaStep\030\r \001(\0132\016.OTANS.OTAStep*\231\001\n"
  "\003Aid\022\016\n\nCONNECTION\020\000\022\n\n\006STATUS\020\001\022\013\n\007CONT"
  "ROL\020\002\022\014\n\010DIAGNOSE\020\003\022\t\n\005ALERT\020\004\022\t\n\005FAULT\020"
  "\005\022\014\n\010ANALYSIS\020\006\022\013\n\007GB32960\020\007\022\010\n\004LOCK\020\010\022\t"
  "\n\005EVENT\020\t\022\007\n\003OTA\020\n\022\014\n\010OTA_STEP\020\013B\035\n\rcom."
  "iov.protoB\014MessageProtoP\000P\001P\002P\003P\004P\005P\006P\007P"
  "\010P\tP\nb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_message_2eproto_deps[11] = {
  &::descriptor_table_alert_2eproto,
  &::descriptor_table_analysis_2eproto,
  &::descriptor_table_connection_2eproto,
  &::descriptor_table_control_2eproto,
  &::descriptor_table_diagnose_2eproto,
  &::descriptor_table_event_2eproto,
  &::descriptor_table_fault_2eproto,
  &::descriptor_table_gb32960_2eproto,
  &::descriptor_table_lock_2eproto,
  &::descriptor_table_ota_2eproto,
  &::descriptor_table_status_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_message_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto = {
  false, false, 853, descriptor_table_protodef_message_2eproto, "message.proto", 
  &descriptor_table_message_2eproto_once, descriptor_table_message_2eproto_deps, 11, 1,
  schemas, file_default_instances, TableStruct_message_2eproto::offsets,
  file_level_metadata_message_2eproto, file_level_enum_descriptors_message_2eproto, file_level_service_descriptors_message_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_message_2eproto_getter() {
  return &descriptor_table_message_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_message_2eproto(&descriptor_table_message_2eproto);
namespace MessageNS {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aid_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_message_2eproto);
  return file_level_enum_descriptors_message_2eproto[0];
}
bool Aid_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Message::_Internal {
 public:
  static const ::ConnectionNS::Connection& connection(const Message* msg);
  static const ::StatusNS::Status& status(const Message* msg);
  static const ::ControlNS::Control& control(const Message* msg);
  static const ::DiagnoseNS::Diagnose& diagnose(const Message* msg);
  static const ::AlertNS::Alert& alert(const Message* msg);
  static const ::FaultNS::Fault& fault(const Message* msg);
  static const ::AnalysisNS::Analysis& analysis(const Message* msg);
  static const ::Gb32960NS::Gb32960& gb32960(const Message* msg);
  static const ::LockNS::Lock& lock(const Message* msg);
  static const ::EventNS::Event& event(const Message* msg);
  static const ::OTANS::OTA& ota(const Message* msg);
  static const ::OTANS::OTAStep& otastep(const Message* msg);
};

const ::ConnectionNS::Connection&
Message::_Internal::connection(const Message* msg) {
  return *msg->connection_;
}
const ::StatusNS::Status&
Message::_Internal::status(const Message* msg) {
  return *msg->status_;
}
const ::ControlNS::Control&
Message::_Internal::control(const Message* msg) {
  return *msg->control_;
}
const ::DiagnoseNS::Diagnose&
Message::_Internal::diagnose(const Message* msg) {
  return *msg->diagnose_;
}
const ::AlertNS::Alert&
Message::_Internal::alert(const Message* msg) {
  return *msg->alert_;
}
const ::FaultNS::Fault&
Message::_Internal::fault(const Message* msg) {
  return *msg->fault_;
}
const ::AnalysisNS::Analysis&
Message::_Internal::analysis(const Message* msg) {
  return *msg->analysis_;
}
const ::Gb32960NS::Gb32960&
Message::_Internal::gb32960(const Message* msg) {
  return *msg->gb32960_;
}
const ::LockNS::Lock&
Message::_Internal::lock(const Message* msg) {
  return *msg->lock_;
}
const ::EventNS::Event&
Message::_Internal::event(const Message* msg) {
  return *msg->event_;
}
const ::OTANS::OTA&
Message::_Internal::ota(const Message* msg) {
  return *msg->ota_;
}
const ::OTANS::OTAStep&
Message::_Internal::otastep(const Message* msg) {
  return *msg->otastep_;
}
void Message::clear_connection() {
  if (GetArenaForAllocation() == nullptr && connection_ != nullptr) {
    delete connection_;
  }
  connection_ = nullptr;
}
void Message::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
void Message::clear_control() {
  if (GetArenaForAllocation() == nullptr && control_ != nullptr) {
    delete control_;
  }
  control_ = nullptr;
}
void Message::clear_diagnose() {
  if (GetArenaForAllocation() == nullptr && diagnose_ != nullptr) {
    delete diagnose_;
  }
  diagnose_ = nullptr;
}
void Message::clear_alert() {
  if (GetArenaForAllocation() == nullptr && alert_ != nullptr) {
    delete alert_;
  }
  alert_ = nullptr;
}
void Message::clear_fault() {
  if (GetArenaForAllocation() == nullptr && fault_ != nullptr) {
    delete fault_;
  }
  fault_ = nullptr;
}
void Message::clear_analysis() {
  if (GetArenaForAllocation() == nullptr && analysis_ != nullptr) {
    delete analysis_;
  }
  analysis_ = nullptr;
}
void Message::clear_gb32960() {
  if (GetArenaForAllocation() == nullptr && gb32960_ != nullptr) {
    delete gb32960_;
  }
  gb32960_ = nullptr;
}
void Message::clear_lock() {
  if (GetArenaForAllocation() == nullptr && lock_ != nullptr) {
    delete lock_;
  }
  lock_ = nullptr;
}
void Message::clear_event() {
  if (GetArenaForAllocation() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
}
void Message::clear_ota() {
  if (GetArenaForAllocation() == nullptr && ota_ != nullptr) {
    delete ota_;
  }
  ota_ = nullptr;
}
void Message::clear_otastep() {
  if (GetArenaForAllocation() == nullptr && otastep_ != nullptr) {
    delete otastep_;
  }
  otastep_ = nullptr;
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MessageNS.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_connection()) {
    connection_ = new ::ConnectionNS::Connection(*from.connection_);
  } else {
    connection_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::StatusNS::Status(*from.status_);
  } else {
    status_ = nullptr;
  }
  if (from._internal_has_control()) {
    control_ = new ::ControlNS::Control(*from.control_);
  } else {
    control_ = nullptr;
  }
  if (from._internal_has_diagnose()) {
    diagnose_ = new ::DiagnoseNS::Diagnose(*from.diagnose_);
  } else {
    diagnose_ = nullptr;
  }
  if (from._internal_has_alert()) {
    alert_ = new ::AlertNS::Alert(*from.alert_);
  } else {
    alert_ = nullptr;
  }
  if (from._internal_has_fault()) {
    fault_ = new ::FaultNS::Fault(*from.fault_);
  } else {
    fault_ = nullptr;
  }
  if (from._internal_has_analysis()) {
    analysis_ = new ::AnalysisNS::Analysis(*from.analysis_);
  } else {
    analysis_ = nullptr;
  }
  if (from._internal_has_gb32960()) {
    gb32960_ = new ::Gb32960NS::Gb32960(*from.gb32960_);
  } else {
    gb32960_ = nullptr;
  }
  if (from._internal_has_lock()) {
    lock_ = new ::LockNS::Lock(*from.lock_);
  } else {
    lock_ = nullptr;
  }
  if (from._internal_has_event()) {
    event_ = new ::EventNS::Event(*from.event_);
  } else {
    event_ = nullptr;
  }
  if (from._internal_has_ota()) {
    ota_ = new ::OTANS::OTA(*from.ota_);
  } else {
    ota_ = nullptr;
  }
  if (from._internal_has_otastep()) {
    otastep_ = new ::OTANS::OTAStep(*from.otastep_);
  } else {
    otastep_ = nullptr;
  }
  aid_ = from.aid_;
  // @@protoc_insertion_point(copy_constructor:MessageNS.Message)
}

inline void Message::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&connection_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&aid_) -
    reinterpret_cast<char*>(&connection_)) + sizeof(aid_));
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:MessageNS.Message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete connection_;
  if (this != internal_default_instance()) delete status_;
  if (this != internal_default_instance()) delete control_;
  if (this != internal_default_instance()) delete diagnose_;
  if (this != internal_default_instance()) delete alert_;
  if (this != internal_default_instance()) delete fault_;
  if (this != internal_default_instance()) delete analysis_;
  if (this != internal_default_instance()) delete gb32960_;
  if (this != internal_default_instance()) delete lock_;
  if (this != internal_default_instance()) delete event_;
  if (this != internal_default_instance()) delete ota_;
  if (this != internal_default_instance()) delete otastep_;
}

void Message::ArenaDtor(void* object) {
  Message* _this = reinterpret_cast< Message* >(object);
  (void)_this;
}
void Message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:MessageNS.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && connection_ != nullptr) {
    delete connection_;
  }
  connection_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  if (GetArenaForAllocation() == nullptr && control_ != nullptr) {
    delete control_;
  }
  control_ = nullptr;
  if (GetArenaForAllocation() == nullptr && diagnose_ != nullptr) {
    delete diagnose_;
  }
  diagnose_ = nullptr;
  if (GetArenaForAllocation() == nullptr && alert_ != nullptr) {
    delete alert_;
  }
  alert_ = nullptr;
  if (GetArenaForAllocation() == nullptr && fault_ != nullptr) {
    delete fault_;
  }
  fault_ = nullptr;
  if (GetArenaForAllocation() == nullptr && analysis_ != nullptr) {
    delete analysis_;
  }
  analysis_ = nullptr;
  if (GetArenaForAllocation() == nullptr && gb32960_ != nullptr) {
    delete gb32960_;
  }
  gb32960_ = nullptr;
  if (GetArenaForAllocation() == nullptr && lock_ != nullptr) {
    delete lock_;
  }
  lock_ = nullptr;
  if (GetArenaForAllocation() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ota_ != nullptr) {
    delete ota_;
  }
  ota_ = nullptr;
  if (GetArenaForAllocation() == nullptr && otastep_ != nullptr) {
    delete otastep_;
  }
  otastep_ = nullptr;
  aid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .MessageNS.Aid aid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aid(static_cast<::MessageNS::Aid>(val));
        } else
          goto handle_unusual;
        continue;
      // .ConnectionNS.Connection connection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StatusNS.Status status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ControlNS.Control control = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_control(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DiagnoseNS.Diagnose diagnose = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_diagnose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AlertNS.Alert alert = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_alert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .FaultNS.Fault fault = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_fault(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AnalysisNS.Analysis analysis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_analysis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Gb32960NS.Gb32960 gb32960 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_gb32960(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LockNS.Lock lock = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_lock(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .EventNS.Event event = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .OTANS.OTA ota = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_ota(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .OTANS.OTAStep otaStep = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_otastep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MessageNS.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .MessageNS.Aid aid = 1;
  if (this->_internal_aid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_aid(), target);
  }

  // .ConnectionNS.Connection connection = 2;
  if (this->_internal_has_connection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::connection(this), target, stream);
  }

  // .StatusNS.Status status = 3;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::status(this), target, stream);
  }

  // .ControlNS.Control control = 4;
  if (this->_internal_has_control()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::control(this), target, stream);
  }

  // .DiagnoseNS.Diagnose diagnose = 5;
  if (this->_internal_has_diagnose()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::diagnose(this), target, stream);
  }

  // .AlertNS.Alert alert = 6;
  if (this->_internal_has_alert()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::alert(this), target, stream);
  }

  // .FaultNS.Fault fault = 7;
  if (this->_internal_has_fault()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::fault(this), target, stream);
  }

  // .AnalysisNS.Analysis analysis = 8;
  if (this->_internal_has_analysis()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::analysis(this), target, stream);
  }

  // .Gb32960NS.Gb32960 gb32960 = 9;
  if (this->_internal_has_gb32960()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::gb32960(this), target, stream);
  }

  // .LockNS.Lock lock = 10;
  if (this->_internal_has_lock()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::lock(this), target, stream);
  }

  // .EventNS.Event event = 11;
  if (this->_internal_has_event()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::event(this), target, stream);
  }

  // .OTANS.OTA ota = 12;
  if (this->_internal_has_ota()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::ota(this), target, stream);
  }

  // .OTANS.OTAStep otaStep = 13;
  if (this->_internal_has_otastep()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::otastep(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MessageNS.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MessageNS.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ConnectionNS.Connection connection = 2;
  if (this->_internal_has_connection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *connection_);
  }

  // .StatusNS.Status status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  // .ControlNS.Control control = 4;
  if (this->_internal_has_control()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *control_);
  }

  // .DiagnoseNS.Diagnose diagnose = 5;
  if (this->_internal_has_diagnose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *diagnose_);
  }

  // .AlertNS.Alert alert = 6;
  if (this->_internal_has_alert()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *alert_);
  }

  // .FaultNS.Fault fault = 7;
  if (this->_internal_has_fault()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fault_);
  }

  // .AnalysisNS.Analysis analysis = 8;
  if (this->_internal_has_analysis()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *analysis_);
  }

  // .Gb32960NS.Gb32960 gb32960 = 9;
  if (this->_internal_has_gb32960()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gb32960_);
  }

  // .LockNS.Lock lock = 10;
  if (this->_internal_has_lock()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lock_);
  }

  // .EventNS.Event event = 11;
  if (this->_internal_has_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *event_);
  }

  // .OTANS.OTA ota = 12;
  if (this->_internal_has_ota()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ota_);
  }

  // .OTANS.OTAStep otaStep = 13;
  if (this->_internal_has_otastep()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *otastep_);
  }

  // .MessageNS.Aid aid = 1;
  if (this->_internal_aid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_aid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }

void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Message *>(to)->MergeFrom(
      static_cast<const Message &>(from));
}


void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MessageNS.Message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_connection()) {
    _internal_mutable_connection()->::ConnectionNS::Connection::MergeFrom(from._internal_connection());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::StatusNS::Status::MergeFrom(from._internal_status());
  }
  if (from._internal_has_control()) {
    _internal_mutable_control()->::ControlNS::Control::MergeFrom(from._internal_control());
  }
  if (from._internal_has_diagnose()) {
    _internal_mutable_diagnose()->::DiagnoseNS::Diagnose::MergeFrom(from._internal_diagnose());
  }
  if (from._internal_has_alert()) {
    _internal_mutable_alert()->::AlertNS::Alert::MergeFrom(from._internal_alert());
  }
  if (from._internal_has_fault()) {
    _internal_mutable_fault()->::FaultNS::Fault::MergeFrom(from._internal_fault());
  }
  if (from._internal_has_analysis()) {
    _internal_mutable_analysis()->::AnalysisNS::Analysis::MergeFrom(from._internal_analysis());
  }
  if (from._internal_has_gb32960()) {
    _internal_mutable_gb32960()->::Gb32960NS::Gb32960::MergeFrom(from._internal_gb32960());
  }
  if (from._internal_has_lock()) {
    _internal_mutable_lock()->::LockNS::Lock::MergeFrom(from._internal_lock());
  }
  if (from._internal_has_event()) {
    _internal_mutable_event()->::EventNS::Event::MergeFrom(from._internal_event());
  }
  if (from._internal_has_ota()) {
    _internal_mutable_ota()->::OTANS::OTA::MergeFrom(from._internal_ota());
  }
  if (from._internal_has_otastep()) {
    _internal_mutable_otastep()->::OTANS::OTAStep::MergeFrom(from._internal_otastep());
  }
  if (from._internal_aid() != 0) {
    _internal_set_aid(from._internal_aid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MessageNS.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, aid_)
      + sizeof(Message::aid_)
      - PROTOBUF_FIELD_OFFSET(Message, connection_)>(
          reinterpret_cast<char*>(&connection_),
          reinterpret_cast<char*>(&other->connection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_message_2eproto_getter, &descriptor_table_message_2eproto_once,
      file_level_metadata_message_2eproto[0]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace MessageNS
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::MessageNS::Message* Arena::CreateMaybeMessage< ::MessageNS::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MessageNS::Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
