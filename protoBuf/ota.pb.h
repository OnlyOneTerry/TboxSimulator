// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ota.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ota_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ota_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "diagnose.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ota_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ota_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ota_2eproto;
namespace OTANS {
class EcuInfo;
struct EcuInfoDefaultTypeInternal;
extern EcuInfoDefaultTypeInternal _EcuInfo_default_instance_;
class OTA;
struct OTADefaultTypeInternal;
extern OTADefaultTypeInternal _OTA_default_instance_;
class OTAReqAck;
struct OTAReqAckDefaultTypeInternal;
extern OTAReqAckDefaultTypeInternal _OTAReqAck_default_instance_;
class OTARequest;
struct OTARequestDefaultTypeInternal;
extern OTARequestDefaultTypeInternal _OTARequest_default_instance_;
class OTAResponse;
struct OTAResponseDefaultTypeInternal;
extern OTAResponseDefaultTypeInternal _OTAResponse_default_instance_;
class OTAResult;
struct OTAResultDefaultTypeInternal;
extern OTAResultDefaultTypeInternal _OTAResult_default_instance_;
class OTAStep;
struct OTAStepDefaultTypeInternal;
extern OTAStepDefaultTypeInternal _OTAStep_default_instance_;
class StepEvent;
struct StepEventDefaultTypeInternal;
extern StepEventDefaultTypeInternal _StepEvent_default_instance_;
}  // namespace OTANS
PROTOBUF_NAMESPACE_OPEN
template<> ::OTANS::EcuInfo* Arena::CreateMaybeMessage<::OTANS::EcuInfo>(Arena*);
template<> ::OTANS::OTA* Arena::CreateMaybeMessage<::OTANS::OTA>(Arena*);
template<> ::OTANS::OTAReqAck* Arena::CreateMaybeMessage<::OTANS::OTAReqAck>(Arena*);
template<> ::OTANS::OTARequest* Arena::CreateMaybeMessage<::OTANS::OTARequest>(Arena*);
template<> ::OTANS::OTAResponse* Arena::CreateMaybeMessage<::OTANS::OTAResponse>(Arena*);
template<> ::OTANS::OTAResult* Arena::CreateMaybeMessage<::OTANS::OTAResult>(Arena*);
template<> ::OTANS::OTAStep* Arena::CreateMaybeMessage<::OTANS::OTAStep>(Arena*);
template<> ::OTANS::StepEvent* Arena::CreateMaybeMessage<::OTANS::StepEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OTANS {

// ===================================================================

class OTA final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTA) */ {
 public:
  inline OTA() : OTA(nullptr) {}
  ~OTA() override;
  explicit constexpr OTA(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTA(const OTA& from);
  OTA(OTA&& from) noexcept
    : OTA() {
    *this = ::std::move(from);
  }

  inline OTA& operator=(const OTA& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTA& operator=(OTA&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTA& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTA* internal_default_instance() {
    return reinterpret_cast<const OTA*>(
               &_OTA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OTA& a, OTA& b) {
    a.Swap(&b);
  }
  inline void Swap(OTA* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTA>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTA& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTA& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTA* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTA";
  }
  protected:
  explicit OTA(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIDFieldNumber = 2,
    kOtaRequestFieldNumber = 3,
    kOtaReqAckFieldNumber = 4,
    kOtaResponseFieldNumber = 5,
    kTimestampFieldNumber = 1,
  };
  // string taskID = 2;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // .OTANS.OTARequest otaRequest = 3;
  bool has_otarequest() const;
  private:
  bool _internal_has_otarequest() const;
  public:
  void clear_otarequest();
  const ::OTANS::OTARequest& otarequest() const;
  PROTOBUF_NODISCARD ::OTANS::OTARequest* release_otarequest();
  ::OTANS::OTARequest* mutable_otarequest();
  void set_allocated_otarequest(::OTANS::OTARequest* otarequest);
  private:
  const ::OTANS::OTARequest& _internal_otarequest() const;
  ::OTANS::OTARequest* _internal_mutable_otarequest();
  public:
  void unsafe_arena_set_allocated_otarequest(
      ::OTANS::OTARequest* otarequest);
  ::OTANS::OTARequest* unsafe_arena_release_otarequest();

  // .OTANS.OTAReqAck otaReqAck = 4;
  bool has_otareqack() const;
  private:
  bool _internal_has_otareqack() const;
  public:
  void clear_otareqack();
  const ::OTANS::OTAReqAck& otareqack() const;
  PROTOBUF_NODISCARD ::OTANS::OTAReqAck* release_otareqack();
  ::OTANS::OTAReqAck* mutable_otareqack();
  void set_allocated_otareqack(::OTANS::OTAReqAck* otareqack);
  private:
  const ::OTANS::OTAReqAck& _internal_otareqack() const;
  ::OTANS::OTAReqAck* _internal_mutable_otareqack();
  public:
  void unsafe_arena_set_allocated_otareqack(
      ::OTANS::OTAReqAck* otareqack);
  ::OTANS::OTAReqAck* unsafe_arena_release_otareqack();

  // .OTANS.OTAResponse otaResponse = 5;
  bool has_otaresponse() const;
  private:
  bool _internal_has_otaresponse() const;
  public:
  void clear_otaresponse();
  const ::OTANS::OTAResponse& otaresponse() const;
  PROTOBUF_NODISCARD ::OTANS::OTAResponse* release_otaresponse();
  ::OTANS::OTAResponse* mutable_otaresponse();
  void set_allocated_otaresponse(::OTANS::OTAResponse* otaresponse);
  private:
  const ::OTANS::OTAResponse& _internal_otaresponse() const;
  ::OTANS::OTAResponse* _internal_mutable_otaresponse();
  public:
  void unsafe_arena_set_allocated_otaresponse(
      ::OTANS::OTAResponse* otaresponse);
  ::OTANS::OTAResponse* unsafe_arena_release_otaresponse();

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.OTA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
  ::OTANS::OTARequest* otarequest_;
  ::OTANS::OTAReqAck* otareqack_;
  ::OTANS::OTAResponse* otaresponse_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class OTARequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTARequest) */ {
 public:
  inline OTARequest() : OTARequest(nullptr) {}
  ~OTARequest() override;
  explicit constexpr OTARequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTARequest(const OTARequest& from);
  OTARequest(OTARequest&& from) noexcept
    : OTARequest() {
    *this = ::std::move(from);
  }

  inline OTARequest& operator=(const OTARequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTARequest& operator=(OTARequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTARequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTARequest* internal_default_instance() {
    return reinterpret_cast<const OTARequest*>(
               &_OTARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OTARequest& a, OTARequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OTARequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTARequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTARequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTARequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTARequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTARequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTARequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTARequest";
  }
  protected:
  explicit OTARequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEcuInfoFieldNumber = 2,
    kTotalSizeFieldNumber = 1,
  };
  // repeated .OTANS.EcuInfo ecuInfo = 2;
  int ecuinfo_size() const;
  private:
  int _internal_ecuinfo_size() const;
  public:
  void clear_ecuinfo();
  ::OTANS::EcuInfo* mutable_ecuinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::EcuInfo >*
      mutable_ecuinfo();
  private:
  const ::OTANS::EcuInfo& _internal_ecuinfo(int index) const;
  ::OTANS::EcuInfo* _internal_add_ecuinfo();
  public:
  const ::OTANS::EcuInfo& ecuinfo(int index) const;
  ::OTANS::EcuInfo* add_ecuinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::EcuInfo >&
      ecuinfo() const;

  // int32 totalSize = 1;
  void clear_totalsize();
  int32_t totalsize() const;
  void set_totalsize(int32_t value);
  private:
  int32_t _internal_totalsize() const;
  void _internal_set_totalsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.OTARequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::EcuInfo > ecuinfo_;
  int32_t totalsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class OTAReqAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTAReqAck) */ {
 public:
  inline OTAReqAck() : OTAReqAck(nullptr) {}
  ~OTAReqAck() override;
  explicit constexpr OTAReqAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTAReqAck(const OTAReqAck& from);
  OTAReqAck(OTAReqAck&& from) noexcept
    : OTAReqAck() {
    *this = ::std::move(from);
  }

  inline OTAReqAck& operator=(const OTAReqAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTAReqAck& operator=(OTAReqAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTAReqAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTAReqAck* internal_default_instance() {
    return reinterpret_cast<const OTAReqAck*>(
               &_OTAReqAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OTAReqAck& a, OTAReqAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OTAReqAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTAReqAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTAReqAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTAReqAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTAReqAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTAReqAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTAReqAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTAReqAck";
  }
  protected:
  explicit OTAReqAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.OTAReqAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class EcuInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.EcuInfo) */ {
 public:
  inline EcuInfo() : EcuInfo(nullptr) {}
  ~EcuInfo() override;
  explicit constexpr EcuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EcuInfo(const EcuInfo& from);
  EcuInfo(EcuInfo&& from) noexcept
    : EcuInfo() {
    *this = ::std::move(from);
  }

  inline EcuInfo& operator=(const EcuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EcuInfo& operator=(EcuInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EcuInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EcuInfo* internal_default_instance() {
    return reinterpret_cast<const EcuInfo*>(
               &_EcuInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EcuInfo& a, EcuInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EcuInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EcuInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EcuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EcuInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EcuInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EcuInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EcuInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.EcuInfo";
  }
  protected:
  explicit EcuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftVerFieldNumber = 3,
    kFileUrlFieldNumber = 4,
    kMd5FieldNumber = 6,
    kIndexFieldNumber = 1,
    kEcuFieldNumber = 2,
    kFileSizeFieldNumber = 5,
  };
  // string softVer = 3;
  void clear_softver();
  const std::string& softver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_softver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_softver();
  PROTOBUF_NODISCARD std::string* release_softver();
  void set_allocated_softver(std::string* softver);
  private:
  const std::string& _internal_softver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softver(const std::string& value);
  std::string* _internal_mutable_softver();
  public:

  // string fileUrl = 4;
  void clear_fileurl();
  const std::string& fileurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileurl();
  PROTOBUF_NODISCARD std::string* release_fileurl();
  void set_allocated_fileurl(std::string* fileurl);
  private:
  const std::string& _internal_fileurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileurl(const std::string& value);
  std::string* _internal_mutable_fileurl();
  public:

  // string md5 = 6;
  void clear_md5();
  const std::string& md5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_md5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* md5);
  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
  std::string* _internal_mutable_md5();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // .DiagnoseNS.Ecus ecu = 2;
  void clear_ecu();
  ::DiagnoseNS::Ecus ecu() const;
  void set_ecu(::DiagnoseNS::Ecus value);
  private:
  ::DiagnoseNS::Ecus _internal_ecu() const;
  void _internal_set_ecu(::DiagnoseNS::Ecus value);
  public:

  // int32 fileSize = 5;
  void clear_filesize();
  int32_t filesize() const;
  void set_filesize(int32_t value);
  private:
  int32_t _internal_filesize() const;
  void _internal_set_filesize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.EcuInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  int32_t index_;
  int ecu_;
  int32_t filesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class OTAResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTAResponse) */ {
 public:
  inline OTAResponse() : OTAResponse(nullptr) {}
  ~OTAResponse() override;
  explicit constexpr OTAResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTAResponse(const OTAResponse& from);
  OTAResponse(OTAResponse&& from) noexcept
    : OTAResponse() {
    *this = ::std::move(from);
  }

  inline OTAResponse& operator=(const OTAResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTAResponse& operator=(OTAResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTAResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTAResponse* internal_default_instance() {
    return reinterpret_cast<const OTAResponse*>(
               &_OTAResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OTAResponse& a, OTAResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OTAResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTAResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTAResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTAResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTAResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTAResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTAResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTAResponse";
  }
  protected:
  explicit OTAResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtaResultFieldNumber = 1,
  };
  // repeated .OTANS.OTAResult otaResult = 1;
  int otaresult_size() const;
  private:
  int _internal_otaresult_size() const;
  public:
  void clear_otaresult();
  ::OTANS::OTAResult* mutable_otaresult(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::OTAResult >*
      mutable_otaresult();
  private:
  const ::OTANS::OTAResult& _internal_otaresult(int index) const;
  ::OTANS::OTAResult* _internal_add_otaresult();
  public:
  const ::OTANS::OTAResult& otaresult(int index) const;
  ::OTANS::OTAResult* add_otaresult();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::OTAResult >&
      otaresult() const;

  // @@protoc_insertion_point(class_scope:OTANS.OTAResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::OTAResult > otaresult_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class OTAResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTAResult) */ {
 public:
  inline OTAResult() : OTAResult(nullptr) {}
  ~OTAResult() override;
  explicit constexpr OTAResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTAResult(const OTAResult& from);
  OTAResult(OTAResult&& from) noexcept
    : OTAResult() {
    *this = ::std::move(from);
  }

  inline OTAResult& operator=(const OTAResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTAResult& operator=(OTAResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTAResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTAResult* internal_default_instance() {
    return reinterpret_cast<const OTAResult*>(
               &_OTAResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OTAResult& a, OTAResult& b) {
    a.Swap(&b);
  }
  inline void Swap(OTAResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTAResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTAResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTAResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTAResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTAResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTAResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTAResult";
  }
  protected:
  explicit OTAResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftVerFieldNumber = 3,
    kIndexFieldNumber = 1,
    kEcuFieldNumber = 2,
    kUpdateStartTimeFieldNumber = 5,
    kUpdateEndTimeFieldNumber = 6,
    kUpdateResultFieldNumber = 4,
  };
  // string softVer = 3;
  void clear_softver();
  const std::string& softver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_softver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_softver();
  PROTOBUF_NODISCARD std::string* release_softver();
  void set_allocated_softver(std::string* softver);
  private:
  const std::string& _internal_softver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softver(const std::string& value);
  std::string* _internal_mutable_softver();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // .DiagnoseNS.Ecus ecu = 2;
  void clear_ecu();
  ::DiagnoseNS::Ecus ecu() const;
  void set_ecu(::DiagnoseNS::Ecus value);
  private:
  ::DiagnoseNS::Ecus _internal_ecu() const;
  void _internal_set_ecu(::DiagnoseNS::Ecus value);
  public:

  // int64 updateStartTime = 5;
  void clear_updatestarttime();
  int64_t updatestarttime() const;
  void set_updatestarttime(int64_t value);
  private:
  int64_t _internal_updatestarttime() const;
  void _internal_set_updatestarttime(int64_t value);
  public:

  // int64 updateEndTime = 6;
  void clear_updateendtime();
  int64_t updateendtime() const;
  void set_updateendtime(int64_t value);
  private:
  int64_t _internal_updateendtime() const;
  void _internal_set_updateendtime(int64_t value);
  public:

  // int32 updateResult = 4;
  void clear_updateresult();
  int32_t updateresult() const;
  void set_updateresult(int32_t value);
  private:
  int32_t _internal_updateresult() const;
  void _internal_set_updateresult(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.OTAResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softver_;
  int32_t index_;
  int ecu_;
  int64_t updatestarttime_;
  int64_t updateendtime_;
  int32_t updateresult_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class OTAStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.OTAStep) */ {
 public:
  inline OTAStep() : OTAStep(nullptr) {}
  ~OTAStep() override;
  explicit constexpr OTAStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OTAStep(const OTAStep& from);
  OTAStep(OTAStep&& from) noexcept
    : OTAStep() {
    *this = ::std::move(from);
  }

  inline OTAStep& operator=(const OTAStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline OTAStep& operator=(OTAStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OTAStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const OTAStep* internal_default_instance() {
    return reinterpret_cast<const OTAStep*>(
               &_OTAStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OTAStep& a, OTAStep& b) {
    a.Swap(&b);
  }
  inline void Swap(OTAStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OTAStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OTAStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OTAStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OTAStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OTAStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OTAStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.OTAStep";
  }
  protected:
  explicit OTAStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepEventFieldNumber = 2,
    kTaskIDFieldNumber = 1,
  };
  // repeated .OTANS.StepEvent stepEvent = 2;
  int stepevent_size() const;
  private:
  int _internal_stepevent_size() const;
  public:
  void clear_stepevent();
  ::OTANS::StepEvent* mutable_stepevent(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::StepEvent >*
      mutable_stepevent();
  private:
  const ::OTANS::StepEvent& _internal_stepevent(int index) const;
  ::OTANS::StepEvent* _internal_add_stepevent();
  public:
  const ::OTANS::StepEvent& stepevent(int index) const;
  ::OTANS::StepEvent* add_stepevent();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::StepEvent >&
      stepevent() const;

  // string taskID = 1;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // @@protoc_insertion_point(class_scope:OTANS.OTAStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::StepEvent > stepevent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// -------------------------------------------------------------------

class StepEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OTANS.StepEvent) */ {
 public:
  inline StepEvent() : StepEvent(nullptr) {}
  ~StepEvent() override;
  explicit constexpr StepEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepEvent(const StepEvent& from);
  StepEvent(StepEvent&& from) noexcept
    : StepEvent() {
    *this = ::std::move(from);
  }

  inline StepEvent& operator=(const StepEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepEvent& operator=(StepEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepEvent* internal_default_instance() {
    return reinterpret_cast<const StepEvent*>(
               &_StepEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StepEvent& a, StepEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(StepEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StepEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OTANS.StepEvent";
  }
  protected:
  explicit StepEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 3,
    kEcuFieldNumber = 1,
    kStepFieldNumber = 2,
  };
  // string desc = 3;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // .DiagnoseNS.Ecus ecu = 1;
  void clear_ecu();
  ::DiagnoseNS::Ecus ecu() const;
  void set_ecu(::DiagnoseNS::Ecus value);
  private:
  ::DiagnoseNS::Ecus _internal_ecu() const;
  void _internal_set_ecu(::DiagnoseNS::Ecus value);
  public:

  // int32 step = 2;
  void clear_step();
  int32_t step() const;
  void set_step(int32_t value);
  private:
  int32_t _internal_step() const;
  void _internal_set_step(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OTANS.StepEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  int ecu_;
  int32_t step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OTA

// int64 timestamp = 1;
inline void OTA::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t OTA::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t OTA::timestamp() const {
  // @@protoc_insertion_point(field_get:OTANS.OTA.timestamp)
  return _internal_timestamp();
}
inline void OTA::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void OTA::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:OTANS.OTA.timestamp)
}

// string taskID = 2;
inline void OTA::clear_taskid() {
  taskid_.ClearToEmpty();
}
inline const std::string& OTA::taskid() const {
  // @@protoc_insertion_point(field_get:OTANS.OTA.taskID)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OTA::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.OTA.taskID)
}
inline std::string* OTA::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:OTANS.OTA.taskID)
  return _s;
}
inline const std::string& OTA::_internal_taskid() const {
  return taskid_.Get();
}
inline void OTA::_internal_set_taskid(const std::string& value) {
  
  taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OTA::_internal_mutable_taskid() {
  
  return taskid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OTA::release_taskid() {
  // @@protoc_insertion_point(field_release:OTANS.OTA.taskID)
  return taskid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OTA::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  taskid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), taskid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (taskid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    taskid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTA.taskID)
}

// .OTANS.OTARequest otaRequest = 3;
inline bool OTA::_internal_has_otarequest() const {
  return this != internal_default_instance() && otarequest_ != nullptr;
}
inline bool OTA::has_otarequest() const {
  return _internal_has_otarequest();
}
inline void OTA::clear_otarequest() {
  if (GetArenaForAllocation() == nullptr && otarequest_ != nullptr) {
    delete otarequest_;
  }
  otarequest_ = nullptr;
}
inline const ::OTANS::OTARequest& OTA::_internal_otarequest() const {
  const ::OTANS::OTARequest* p = otarequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::OTANS::OTARequest&>(
      ::OTANS::_OTARequest_default_instance_);
}
inline const ::OTANS::OTARequest& OTA::otarequest() const {
  // @@protoc_insertion_point(field_get:OTANS.OTA.otaRequest)
  return _internal_otarequest();
}
inline void OTA::unsafe_arena_set_allocated_otarequest(
    ::OTANS::OTARequest* otarequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(otarequest_);
  }
  otarequest_ = otarequest;
  if (otarequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OTANS.OTA.otaRequest)
}
inline ::OTANS::OTARequest* OTA::release_otarequest() {
  
  ::OTANS::OTARequest* temp = otarequest_;
  otarequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OTANS::OTARequest* OTA::unsafe_arena_release_otarequest() {
  // @@protoc_insertion_point(field_release:OTANS.OTA.otaRequest)
  
  ::OTANS::OTARequest* temp = otarequest_;
  otarequest_ = nullptr;
  return temp;
}
inline ::OTANS::OTARequest* OTA::_internal_mutable_otarequest() {
  
  if (otarequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::OTANS::OTARequest>(GetArenaForAllocation());
    otarequest_ = p;
  }
  return otarequest_;
}
inline ::OTANS::OTARequest* OTA::mutable_otarequest() {
  ::OTANS::OTARequest* _msg = _internal_mutable_otarequest();
  // @@protoc_insertion_point(field_mutable:OTANS.OTA.otaRequest)
  return _msg;
}
inline void OTA::set_allocated_otarequest(::OTANS::OTARequest* otarequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete otarequest_;
  }
  if (otarequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::OTANS::OTARequest>::GetOwningArena(otarequest);
    if (message_arena != submessage_arena) {
      otarequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, otarequest, submessage_arena);
    }
    
  } else {
    
  }
  otarequest_ = otarequest;
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTA.otaRequest)
}

// .OTANS.OTAReqAck otaReqAck = 4;
inline bool OTA::_internal_has_otareqack() const {
  return this != internal_default_instance() && otareqack_ != nullptr;
}
inline bool OTA::has_otareqack() const {
  return _internal_has_otareqack();
}
inline void OTA::clear_otareqack() {
  if (GetArenaForAllocation() == nullptr && otareqack_ != nullptr) {
    delete otareqack_;
  }
  otareqack_ = nullptr;
}
inline const ::OTANS::OTAReqAck& OTA::_internal_otareqack() const {
  const ::OTANS::OTAReqAck* p = otareqack_;
  return p != nullptr ? *p : reinterpret_cast<const ::OTANS::OTAReqAck&>(
      ::OTANS::_OTAReqAck_default_instance_);
}
inline const ::OTANS::OTAReqAck& OTA::otareqack() const {
  // @@protoc_insertion_point(field_get:OTANS.OTA.otaReqAck)
  return _internal_otareqack();
}
inline void OTA::unsafe_arena_set_allocated_otareqack(
    ::OTANS::OTAReqAck* otareqack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(otareqack_);
  }
  otareqack_ = otareqack;
  if (otareqack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OTANS.OTA.otaReqAck)
}
inline ::OTANS::OTAReqAck* OTA::release_otareqack() {
  
  ::OTANS::OTAReqAck* temp = otareqack_;
  otareqack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OTANS::OTAReqAck* OTA::unsafe_arena_release_otareqack() {
  // @@protoc_insertion_point(field_release:OTANS.OTA.otaReqAck)
  
  ::OTANS::OTAReqAck* temp = otareqack_;
  otareqack_ = nullptr;
  return temp;
}
inline ::OTANS::OTAReqAck* OTA::_internal_mutable_otareqack() {
  
  if (otareqack_ == nullptr) {
    auto* p = CreateMaybeMessage<::OTANS::OTAReqAck>(GetArenaForAllocation());
    otareqack_ = p;
  }
  return otareqack_;
}
inline ::OTANS::OTAReqAck* OTA::mutable_otareqack() {
  ::OTANS::OTAReqAck* _msg = _internal_mutable_otareqack();
  // @@protoc_insertion_point(field_mutable:OTANS.OTA.otaReqAck)
  return _msg;
}
inline void OTA::set_allocated_otareqack(::OTANS::OTAReqAck* otareqack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete otareqack_;
  }
  if (otareqack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::OTANS::OTAReqAck>::GetOwningArena(otareqack);
    if (message_arena != submessage_arena) {
      otareqack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, otareqack, submessage_arena);
    }
    
  } else {
    
  }
  otareqack_ = otareqack;
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTA.otaReqAck)
}

// .OTANS.OTAResponse otaResponse = 5;
inline bool OTA::_internal_has_otaresponse() const {
  return this != internal_default_instance() && otaresponse_ != nullptr;
}
inline bool OTA::has_otaresponse() const {
  return _internal_has_otaresponse();
}
inline void OTA::clear_otaresponse() {
  if (GetArenaForAllocation() == nullptr && otaresponse_ != nullptr) {
    delete otaresponse_;
  }
  otaresponse_ = nullptr;
}
inline const ::OTANS::OTAResponse& OTA::_internal_otaresponse() const {
  const ::OTANS::OTAResponse* p = otaresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::OTANS::OTAResponse&>(
      ::OTANS::_OTAResponse_default_instance_);
}
inline const ::OTANS::OTAResponse& OTA::otaresponse() const {
  // @@protoc_insertion_point(field_get:OTANS.OTA.otaResponse)
  return _internal_otaresponse();
}
inline void OTA::unsafe_arena_set_allocated_otaresponse(
    ::OTANS::OTAResponse* otaresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(otaresponse_);
  }
  otaresponse_ = otaresponse;
  if (otaresponse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OTANS.OTA.otaResponse)
}
inline ::OTANS::OTAResponse* OTA::release_otaresponse() {
  
  ::OTANS::OTAResponse* temp = otaresponse_;
  otaresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OTANS::OTAResponse* OTA::unsafe_arena_release_otaresponse() {
  // @@protoc_insertion_point(field_release:OTANS.OTA.otaResponse)
  
  ::OTANS::OTAResponse* temp = otaresponse_;
  otaresponse_ = nullptr;
  return temp;
}
inline ::OTANS::OTAResponse* OTA::_internal_mutable_otaresponse() {
  
  if (otaresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::OTANS::OTAResponse>(GetArenaForAllocation());
    otaresponse_ = p;
  }
  return otaresponse_;
}
inline ::OTANS::OTAResponse* OTA::mutable_otaresponse() {
  ::OTANS::OTAResponse* _msg = _internal_mutable_otaresponse();
  // @@protoc_insertion_point(field_mutable:OTANS.OTA.otaResponse)
  return _msg;
}
inline void OTA::set_allocated_otaresponse(::OTANS::OTAResponse* otaresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete otaresponse_;
  }
  if (otaresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::OTANS::OTAResponse>::GetOwningArena(otaresponse);
    if (message_arena != submessage_arena) {
      otaresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, otaresponse, submessage_arena);
    }
    
  } else {
    
  }
  otaresponse_ = otaresponse;
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTA.otaResponse)
}

// -------------------------------------------------------------------

// OTARequest

// int32 totalSize = 1;
inline void OTARequest::clear_totalsize() {
  totalsize_ = 0;
}
inline int32_t OTARequest::_internal_totalsize() const {
  return totalsize_;
}
inline int32_t OTARequest::totalsize() const {
  // @@protoc_insertion_point(field_get:OTANS.OTARequest.totalSize)
  return _internal_totalsize();
}
inline void OTARequest::_internal_set_totalsize(int32_t value) {
  
  totalsize_ = value;
}
inline void OTARequest::set_totalsize(int32_t value) {
  _internal_set_totalsize(value);
  // @@protoc_insertion_point(field_set:OTANS.OTARequest.totalSize)
}

// repeated .OTANS.EcuInfo ecuInfo = 2;
inline int OTARequest::_internal_ecuinfo_size() const {
  return ecuinfo_.size();
}
inline int OTARequest::ecuinfo_size() const {
  return _internal_ecuinfo_size();
}
inline void OTARequest::clear_ecuinfo() {
  ecuinfo_.Clear();
}
inline ::OTANS::EcuInfo* OTARequest::mutable_ecuinfo(int index) {
  // @@protoc_insertion_point(field_mutable:OTANS.OTARequest.ecuInfo)
  return ecuinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::EcuInfo >*
OTARequest::mutable_ecuinfo() {
  // @@protoc_insertion_point(field_mutable_list:OTANS.OTARequest.ecuInfo)
  return &ecuinfo_;
}
inline const ::OTANS::EcuInfo& OTARequest::_internal_ecuinfo(int index) const {
  return ecuinfo_.Get(index);
}
inline const ::OTANS::EcuInfo& OTARequest::ecuinfo(int index) const {
  // @@protoc_insertion_point(field_get:OTANS.OTARequest.ecuInfo)
  return _internal_ecuinfo(index);
}
inline ::OTANS::EcuInfo* OTARequest::_internal_add_ecuinfo() {
  return ecuinfo_.Add();
}
inline ::OTANS::EcuInfo* OTARequest::add_ecuinfo() {
  ::OTANS::EcuInfo* _add = _internal_add_ecuinfo();
  // @@protoc_insertion_point(field_add:OTANS.OTARequest.ecuInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::EcuInfo >&
OTARequest::ecuinfo() const {
  // @@protoc_insertion_point(field_list:OTANS.OTARequest.ecuInfo)
  return ecuinfo_;
}

// -------------------------------------------------------------------

// OTAReqAck

// uint32 result = 1;
inline void OTAReqAck::clear_result() {
  result_ = 0u;
}
inline uint32_t OTAReqAck::_internal_result() const {
  return result_;
}
inline uint32_t OTAReqAck::result() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAReqAck.result)
  return _internal_result();
}
inline void OTAReqAck::_internal_set_result(uint32_t value) {
  
  result_ = value;
}
inline void OTAReqAck::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAReqAck.result)
}

// -------------------------------------------------------------------

// EcuInfo

// int32 index = 1;
inline void EcuInfo::clear_index() {
  index_ = 0;
}
inline int32_t EcuInfo::_internal_index() const {
  return index_;
}
inline int32_t EcuInfo::index() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.index)
  return _internal_index();
}
inline void EcuInfo::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void EcuInfo::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.index)
}

// .DiagnoseNS.Ecus ecu = 2;
inline void EcuInfo::clear_ecu() {
  ecu_ = 0;
}
inline ::DiagnoseNS::Ecus EcuInfo::_internal_ecu() const {
  return static_cast< ::DiagnoseNS::Ecus >(ecu_);
}
inline ::DiagnoseNS::Ecus EcuInfo::ecu() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.ecu)
  return _internal_ecu();
}
inline void EcuInfo::_internal_set_ecu(::DiagnoseNS::Ecus value) {
  
  ecu_ = value;
}
inline void EcuInfo::set_ecu(::DiagnoseNS::Ecus value) {
  _internal_set_ecu(value);
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.ecu)
}

// string softVer = 3;
inline void EcuInfo::clear_softver() {
  softver_.ClearToEmpty();
}
inline const std::string& EcuInfo::softver() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.softVer)
  return _internal_softver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EcuInfo::set_softver(ArgT0&& arg0, ArgT... args) {
 
 softver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.softVer)
}
inline std::string* EcuInfo::mutable_softver() {
  std::string* _s = _internal_mutable_softver();
  // @@protoc_insertion_point(field_mutable:OTANS.EcuInfo.softVer)
  return _s;
}
inline const std::string& EcuInfo::_internal_softver() const {
  return softver_.Get();
}
inline void EcuInfo::_internal_set_softver(const std::string& value) {
  
  softver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EcuInfo::_internal_mutable_softver() {
  
  return softver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EcuInfo::release_softver() {
  // @@protoc_insertion_point(field_release:OTANS.EcuInfo.softVer)
  return softver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EcuInfo::set_allocated_softver(std::string* softver) {
  if (softver != nullptr) {
    
  } else {
    
  }
  softver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softver,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (softver_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    softver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.EcuInfo.softVer)
}

// string fileUrl = 4;
inline void EcuInfo::clear_fileurl() {
  fileurl_.ClearToEmpty();
}
inline const std::string& EcuInfo::fileurl() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.fileUrl)
  return _internal_fileurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EcuInfo::set_fileurl(ArgT0&& arg0, ArgT... args) {
 
 fileurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.fileUrl)
}
inline std::string* EcuInfo::mutable_fileurl() {
  std::string* _s = _internal_mutable_fileurl();
  // @@protoc_insertion_point(field_mutable:OTANS.EcuInfo.fileUrl)
  return _s;
}
inline const std::string& EcuInfo::_internal_fileurl() const {
  return fileurl_.Get();
}
inline void EcuInfo::_internal_set_fileurl(const std::string& value) {
  
  fileurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EcuInfo::_internal_mutable_fileurl() {
  
  return fileurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EcuInfo::release_fileurl() {
  // @@protoc_insertion_point(field_release:OTANS.EcuInfo.fileUrl)
  return fileurl_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EcuInfo::set_allocated_fileurl(std::string* fileurl) {
  if (fileurl != nullptr) {
    
  } else {
    
  }
  fileurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fileurl,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fileurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fileurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.EcuInfo.fileUrl)
}

// int32 fileSize = 5;
inline void EcuInfo::clear_filesize() {
  filesize_ = 0;
}
inline int32_t EcuInfo::_internal_filesize() const {
  return filesize_;
}
inline int32_t EcuInfo::filesize() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.fileSize)
  return _internal_filesize();
}
inline void EcuInfo::_internal_set_filesize(int32_t value) {
  
  filesize_ = value;
}
inline void EcuInfo::set_filesize(int32_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.fileSize)
}

// string md5 = 6;
inline void EcuInfo::clear_md5() {
  md5_.ClearToEmpty();
}
inline const std::string& EcuInfo::md5() const {
  // @@protoc_insertion_point(field_get:OTANS.EcuInfo.md5)
  return _internal_md5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EcuInfo::set_md5(ArgT0&& arg0, ArgT... args) {
 
 md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.EcuInfo.md5)
}
inline std::string* EcuInfo::mutable_md5() {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:OTANS.EcuInfo.md5)
  return _s;
}
inline const std::string& EcuInfo::_internal_md5() const {
  return md5_.Get();
}
inline void EcuInfo::_internal_set_md5(const std::string& value) {
  
  md5_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EcuInfo::_internal_mutable_md5() {
  
  return md5_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EcuInfo::release_md5() {
  // @@protoc_insertion_point(field_release:OTANS.EcuInfo.md5)
  return md5_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EcuInfo::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (md5_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    md5_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.EcuInfo.md5)
}

// -------------------------------------------------------------------

// OTAResponse

// repeated .OTANS.OTAResult otaResult = 1;
inline int OTAResponse::_internal_otaresult_size() const {
  return otaresult_.size();
}
inline int OTAResponse::otaresult_size() const {
  return _internal_otaresult_size();
}
inline void OTAResponse::clear_otaresult() {
  otaresult_.Clear();
}
inline ::OTANS::OTAResult* OTAResponse::mutable_otaresult(int index) {
  // @@protoc_insertion_point(field_mutable:OTANS.OTAResponse.otaResult)
  return otaresult_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::OTAResult >*
OTAResponse::mutable_otaresult() {
  // @@protoc_insertion_point(field_mutable_list:OTANS.OTAResponse.otaResult)
  return &otaresult_;
}
inline const ::OTANS::OTAResult& OTAResponse::_internal_otaresult(int index) const {
  return otaresult_.Get(index);
}
inline const ::OTANS::OTAResult& OTAResponse::otaresult(int index) const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResponse.otaResult)
  return _internal_otaresult(index);
}
inline ::OTANS::OTAResult* OTAResponse::_internal_add_otaresult() {
  return otaresult_.Add();
}
inline ::OTANS::OTAResult* OTAResponse::add_otaresult() {
  ::OTANS::OTAResult* _add = _internal_add_otaresult();
  // @@protoc_insertion_point(field_add:OTANS.OTAResponse.otaResult)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::OTAResult >&
OTAResponse::otaresult() const {
  // @@protoc_insertion_point(field_list:OTANS.OTAResponse.otaResult)
  return otaresult_;
}

// -------------------------------------------------------------------

// OTAResult

// int32 index = 1;
inline void OTAResult::clear_index() {
  index_ = 0;
}
inline int32_t OTAResult::_internal_index() const {
  return index_;
}
inline int32_t OTAResult::index() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.index)
  return _internal_index();
}
inline void OTAResult::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void OTAResult::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.index)
}

// .DiagnoseNS.Ecus ecu = 2;
inline void OTAResult::clear_ecu() {
  ecu_ = 0;
}
inline ::DiagnoseNS::Ecus OTAResult::_internal_ecu() const {
  return static_cast< ::DiagnoseNS::Ecus >(ecu_);
}
inline ::DiagnoseNS::Ecus OTAResult::ecu() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.ecu)
  return _internal_ecu();
}
inline void OTAResult::_internal_set_ecu(::DiagnoseNS::Ecus value) {
  
  ecu_ = value;
}
inline void OTAResult::set_ecu(::DiagnoseNS::Ecus value) {
  _internal_set_ecu(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.ecu)
}

// string softVer = 3;
inline void OTAResult::clear_softver() {
  softver_.ClearToEmpty();
}
inline const std::string& OTAResult::softver() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.softVer)
  return _internal_softver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OTAResult::set_softver(ArgT0&& arg0, ArgT... args) {
 
 softver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.softVer)
}
inline std::string* OTAResult::mutable_softver() {
  std::string* _s = _internal_mutable_softver();
  // @@protoc_insertion_point(field_mutable:OTANS.OTAResult.softVer)
  return _s;
}
inline const std::string& OTAResult::_internal_softver() const {
  return softver_.Get();
}
inline void OTAResult::_internal_set_softver(const std::string& value) {
  
  softver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OTAResult::_internal_mutable_softver() {
  
  return softver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OTAResult::release_softver() {
  // @@protoc_insertion_point(field_release:OTANS.OTAResult.softVer)
  return softver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OTAResult::set_allocated_softver(std::string* softver) {
  if (softver != nullptr) {
    
  } else {
    
  }
  softver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softver,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (softver_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    softver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTAResult.softVer)
}

// int32 updateResult = 4;
inline void OTAResult::clear_updateresult() {
  updateresult_ = 0;
}
inline int32_t OTAResult::_internal_updateresult() const {
  return updateresult_;
}
inline int32_t OTAResult::updateresult() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.updateResult)
  return _internal_updateresult();
}
inline void OTAResult::_internal_set_updateresult(int32_t value) {
  
  updateresult_ = value;
}
inline void OTAResult::set_updateresult(int32_t value) {
  _internal_set_updateresult(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.updateResult)
}

// int64 updateStartTime = 5;
inline void OTAResult::clear_updatestarttime() {
  updatestarttime_ = int64_t{0};
}
inline int64_t OTAResult::_internal_updatestarttime() const {
  return updatestarttime_;
}
inline int64_t OTAResult::updatestarttime() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.updateStartTime)
  return _internal_updatestarttime();
}
inline void OTAResult::_internal_set_updatestarttime(int64_t value) {
  
  updatestarttime_ = value;
}
inline void OTAResult::set_updatestarttime(int64_t value) {
  _internal_set_updatestarttime(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.updateStartTime)
}

// int64 updateEndTime = 6;
inline void OTAResult::clear_updateendtime() {
  updateendtime_ = int64_t{0};
}
inline int64_t OTAResult::_internal_updateendtime() const {
  return updateendtime_;
}
inline int64_t OTAResult::updateendtime() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAResult.updateEndTime)
  return _internal_updateendtime();
}
inline void OTAResult::_internal_set_updateendtime(int64_t value) {
  
  updateendtime_ = value;
}
inline void OTAResult::set_updateendtime(int64_t value) {
  _internal_set_updateendtime(value);
  // @@protoc_insertion_point(field_set:OTANS.OTAResult.updateEndTime)
}

// -------------------------------------------------------------------

// OTAStep

// string taskID = 1;
inline void OTAStep::clear_taskid() {
  taskid_.ClearToEmpty();
}
inline const std::string& OTAStep::taskid() const {
  // @@protoc_insertion_point(field_get:OTANS.OTAStep.taskID)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OTAStep::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.OTAStep.taskID)
}
inline std::string* OTAStep::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:OTANS.OTAStep.taskID)
  return _s;
}
inline const std::string& OTAStep::_internal_taskid() const {
  return taskid_.Get();
}
inline void OTAStep::_internal_set_taskid(const std::string& value) {
  
  taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OTAStep::_internal_mutable_taskid() {
  
  return taskid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OTAStep::release_taskid() {
  // @@protoc_insertion_point(field_release:OTANS.OTAStep.taskID)
  return taskid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OTAStep::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  taskid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), taskid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (taskid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    taskid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.OTAStep.taskID)
}

// repeated .OTANS.StepEvent stepEvent = 2;
inline int OTAStep::_internal_stepevent_size() const {
  return stepevent_.size();
}
inline int OTAStep::stepevent_size() const {
  return _internal_stepevent_size();
}
inline void OTAStep::clear_stepevent() {
  stepevent_.Clear();
}
inline ::OTANS::StepEvent* OTAStep::mutable_stepevent(int index) {
  // @@protoc_insertion_point(field_mutable:OTANS.OTAStep.stepEvent)
  return stepevent_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::StepEvent >*
OTAStep::mutable_stepevent() {
  // @@protoc_insertion_point(field_mutable_list:OTANS.OTAStep.stepEvent)
  return &stepevent_;
}
inline const ::OTANS::StepEvent& OTAStep::_internal_stepevent(int index) const {
  return stepevent_.Get(index);
}
inline const ::OTANS::StepEvent& OTAStep::stepevent(int index) const {
  // @@protoc_insertion_point(field_get:OTANS.OTAStep.stepEvent)
  return _internal_stepevent(index);
}
inline ::OTANS::StepEvent* OTAStep::_internal_add_stepevent() {
  return stepevent_.Add();
}
inline ::OTANS::StepEvent* OTAStep::add_stepevent() {
  ::OTANS::StepEvent* _add = _internal_add_stepevent();
  // @@protoc_insertion_point(field_add:OTANS.OTAStep.stepEvent)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OTANS::StepEvent >&
OTAStep::stepevent() const {
  // @@protoc_insertion_point(field_list:OTANS.OTAStep.stepEvent)
  return stepevent_;
}

// -------------------------------------------------------------------

// StepEvent

// .DiagnoseNS.Ecus ecu = 1;
inline void StepEvent::clear_ecu() {
  ecu_ = 0;
}
inline ::DiagnoseNS::Ecus StepEvent::_internal_ecu() const {
  return static_cast< ::DiagnoseNS::Ecus >(ecu_);
}
inline ::DiagnoseNS::Ecus StepEvent::ecu() const {
  // @@protoc_insertion_point(field_get:OTANS.StepEvent.ecu)
  return _internal_ecu();
}
inline void StepEvent::_internal_set_ecu(::DiagnoseNS::Ecus value) {
  
  ecu_ = value;
}
inline void StepEvent::set_ecu(::DiagnoseNS::Ecus value) {
  _internal_set_ecu(value);
  // @@protoc_insertion_point(field_set:OTANS.StepEvent.ecu)
}

// int32 step = 2;
inline void StepEvent::clear_step() {
  step_ = 0;
}
inline int32_t StepEvent::_internal_step() const {
  return step_;
}
inline int32_t StepEvent::step() const {
  // @@protoc_insertion_point(field_get:OTANS.StepEvent.step)
  return _internal_step();
}
inline void StepEvent::_internal_set_step(int32_t value) {
  
  step_ = value;
}
inline void StepEvent::set_step(int32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:OTANS.StepEvent.step)
}

// string desc = 3;
inline void StepEvent::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& StepEvent::desc() const {
  // @@protoc_insertion_point(field_get:OTANS.StepEvent.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StepEvent::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OTANS.StepEvent.desc)
}
inline std::string* StepEvent::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:OTANS.StepEvent.desc)
  return _s;
}
inline const std::string& StepEvent::_internal_desc() const {
  return desc_.Get();
}
inline void StepEvent::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StepEvent::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StepEvent::release_desc() {
  // @@protoc_insertion_point(field_release:OTANS.StepEvent.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StepEvent::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OTANS.StepEvent.desc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace OTANS

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ota_2eproto
